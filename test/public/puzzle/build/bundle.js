var app=function(){"use strict";function t(){}function e(t){return t()}function n(){return Object.create(null)}function i(t){t.forEach(e)}function o(t){return"function"==typeof t}function s(t,e){return t!=t?e==e:t!==e||t&&"object"==typeof t||"function"==typeof t}function r(e,n,i){e.$$.on_destroy.push(function(e,...n){if(null==e)return t;const i=e.subscribe(...n);return i.unsubscribe?()=>i.unsubscribe():i}(n,i))}function l(t,e,n){return t.set(n),e}function a(t,e){t.appendChild(e)}function d(t,e,n){t.insertBefore(e,n||null)}function h(t){t.parentNode&&t.parentNode.removeChild(t)}function c(t){return document.createElementNS("http://www.w3.org/2000/svg",t)}function u(){return t="",document.createTextNode(t);var t}function f(t,e,n){null==n?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}function g(t,e,n,i){null===n?t.style.removeProperty(e):t.style.setProperty(e,n,i?"important":"")}function p(t,e,n){t.classList[n?"add":"remove"](e)}let m;function _(t){m=t}function w(t){(function(){if(!m)throw new Error("Function called outside component initialization");return m})().$$.on_mount.push(t)}const y=[],M=[];let b=[];const v=[],T=Promise.resolve();let I=!1;function x(t){b.push(t)}const S=new Set;let k=0;function E(){if(0!==k)return;const t=m;do{try{for(;k<y.length;){const t=y[k];k++,_(t),C(t.$$)}}catch(t){throw y.length=0,k=0,t}for(_(null),y.length=0,k=0;M.length;)M.pop()();for(let t=0;t<b.length;t+=1){const e=b[t];S.has(e)||(S.add(e),e())}b.length=0}while(y.length);for(;v.length;)v.pop()();I=!1,S.clear(),_(t)}function C(t){if(null!==t.fragment){t.update(),i(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(x)}}const D=new Set;let $;function O(){$={r:0,c:[],p:$}}function N(){$.r||i($.c),$=$.p}function P(t,e){t&&t.i&&(D.delete(t),t.i(e))}function R(t,e,n,i){if(t&&t.o){if(D.has(t))return;D.add(t),$.c.push((()=>{D.delete(t),i&&(n&&t.d(1),i())})),t.o(e)}else i&&i()}function A(t,e){R(t,1,1,(()=>{e.delete(t.key)}))}function z(t){t&&t.c()}function X(t,n,s,r){const{fragment:l,after_update:a}=t.$$;l&&l.m(n,s),r||x((()=>{const n=t.$$.on_mount.map(e).filter(o);t.$$.on_destroy?t.$$.on_destroy.push(...n):i(n),t.$$.on_mount=[]})),a.forEach(x)}function L(t,e){const n=t.$$;null!==n.fragment&&(!function(t){const e=[],n=[];b.forEach((i=>-1===t.indexOf(i)?e.push(i):n.push(i))),n.forEach((t=>t())),b=e}(n.after_update),i(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function Y(t,e){-1===t.$$.dirty[0]&&(y.push(t),I||(I=!0,T.then(E)),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function W(e,o,s,r,l,a,d,c=[-1]){const u=m;_(e);const f=e.$$={fragment:null,ctx:[],props:a,update:t,not_equal:l,bound:n(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(o.context||(u?u.$$.context:[])),callbacks:n(),dirty:c,skip_bound:!1,root:o.target||u.$$.root};d&&d(f.root);let g=!1;if(f.ctx=s?s(e,o.props||{},((t,n,...i)=>{const o=i.length?i[0]:n;return f.ctx&&l(f.ctx[t],f.ctx[t]=o)&&(!f.skip_bound&&f.bound[t]&&f.bound[t](o),g&&Y(e,t)),n})):[],f.update(),g=!0,i(f.before_update),f.fragment=!!r&&r(f.ctx),o.target){if(o.hydrate){const t=function(t){return Array.from(t.childNodes)}(o.target);f.fragment&&f.fragment.l(t),t.forEach(h)}else f.fragment&&f.fragment.c();o.intro&&P(e.$$.fragment),X(e,o.target,o.anchor,o.customElement),E()}_(u)}class H{$destroy(){L(this,1),this.$destroy=t}$on(e,n){if(!o(n))return t;const i=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return i.push(n),()=>{const t=i.indexOf(n);-1!==t&&i.splice(t,1)}}$set(t){var e;this.$$set&&(e=t,0!==Object.keys(e).length)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}const K=[];function G(e,n=t){let i;const o=new Set;function r(t){if(s(e,t)&&(e=t,i)){const t=!K.length;for(const t of o)t[1](),K.push(t,e);if(t){for(let t=0;t<K.length;t+=2)K[t][0](K[t+1]);K.length=0}}}return{set:r,update:function(t){r(t(e))},subscribe:function(s,l=t){const a=[s,l];return o.add(a),1===o.size&&(i=n(r)||t),s(e),()=>{o.delete(a),0===o.size&&i&&(i(),i=null)}}}}const U=function(){const{subscribe:t,set:e,update:n}=G({controlMode:"rotate_lock",invertRotationDirection:!1,showTimer:!0,disableZoomPan:!1,assistant:!1,animationSpeed:"normal"});return{subscribe:t}}();function q(t,e){const n=e.grid;let i;const o=e.viewBox.subscribe((t=>{i=t}));let s;const r=U.subscribe((t=>{s=t})),l=!s.disableZoomPan;let a,d="idle",h={x:0,y:0,button:0,tileIndex:0,tileX:0,tileY:0,locking:!1},c=new Set;function u(e){const{x:n,y:o,width:s,height:r}=t.getBoundingClientRect(),l=(e.clientX-n)/s,a=(e.clientY-o)/r;return[i.xmin+l*i.width,i.ymin+a*i.height]}function f(){t.dispatchEvent(new CustomEvent("save"))}function g(t){t.preventDefault();const[i,o]=u(t);h={x:i,y:o,button:t.button,tileIndex:-1,tileX:0,tileY:0,locking:!1};const r=e.grid.which_tile_at(i,o);if(-1!==r.index&&(h.tileIndex=r.index,h.tileX=r.x,h.tileY=r.y),-1===h.tileIndex)d=l?!n.wrap&&(i<n.XMIN||i>n.XMAX||o<n.YMIN||o>n.YMAX)?"idle":"panning":"idle";else{const{direction:t,isClose:n}=e.grid.whichEdge(h);n?(a=setTimeout((()=>{const n=0===h.button?"wall":"conn";e.toggleEdgeMark(n,h.tileIndex,t,s.assistant),d="edgemark"}),300),d="mousedown"):h.locking?(c.add(h.tileIndex),d="unlocking",f()):d="mousedown"}}function p(t){if(clearTimeout(a),"idle"===d||"edgemark"===d)return;t.preventDefault();const[n,i]=u(t),o=n-h.x,r=i-h.y,l=Math.sqrt(o*o+r*r);if("mousedown"===d&&h.tileIndex,"mousedown"===d&&-1!==h.tileIndex&&l<=.2){const o=h.tileIndex,r=e.tileStates[o],l=0===h.button,a=2===h.button;if("rotate_lock"===s.controlMode){let n=s.invertRotationDirection?-1:1;l&&!t.ctrlKey?e.rotateTile(o,n):l&&t.ctrlKey&&e.rotateTile(o,-n)}else if("rotate_rotate"===s.controlMode){let n=s.invertRotationDirection?-1:1;l&&t.ctrlKey||(l&&!t.ctrlKey?e.rotateTile(o,n):a&&e.rotateTile(o,-n))}else if("orient_lock"===s.controlMode&&l){const{tileX:t,tileY:s}=h,l=Math.atan2(s-i,n-t),a=e.grid.clickOrientTile(r.data.tile,r.data.rotations,l,o);e.rotateTile(o,a)}f()}c.clear(),d="idle"}return t.addEventListener("mousedown",g),document.addEventListener("mouseup",p),{destroy(){t.removeEventListener("mousedown",g),document.removeEventListener("mouseup",p),o(),r()}}}function B(e){let n,i,o,s,r,l,u,p,m=e[12]&&function(t){let e,n,i;return{c(){e=c("circle"),f(e,"cx","0"),f(e,"cy","0"),f(e,"r",n=t[1].grid.SINK_RADIUS),f(e,"fill",i=t[5].color),f(e,"stroke",t[6]),f(e,"stroke-width",t[4]),f(e,"class","inside")},m(t,n){d(t,e,n)},p(t,o){2&o&&n!==(n=t[1].grid.SINK_RADIUS)&&f(e,"r",n),32&o&&i!==(i=t[5].color)&&f(e,"fill",i),64&o&&f(e,"stroke",t[6]),16&o&&f(e,"stroke-width",t[4])},d(t){t&&h(e)}}}(e);return{c(){n=c("g"),i=c("path"),s=c("g"),r=c("path"),m&&m.c(),l=c("path"),f(i,"d",o=e[1].grid.getTilePath(e[0])),f(i,"fill","transparent"),f(i,"stroke-width","0.02"),f(i,"stroke","rgba(255,255,255,.3)"),f(r,"d",e[11]),f(r,"stroke",e[6]),f(r,"stroke-width",e[7]),f(r,"stroke-linejoin","bevel"),f(r,"stroke-linecap","round"),f(l,"class","inside"),f(l,"d",e[11]),f(l,"stroke",u=e[5].color),f(l,"stroke-width",e[10]),f(l,"stroke-linejoin","round"),f(l,"stroke-linecap","round"),f(s,"class","pipe svelte-4ftgik"),g(s,"transform","rotate("+e[1].grid.getAngle(e[5].rotations,e[0])+"rad)"),f(n,"class","tile"),f(n,"transform",p="translate("+e[2]+","+e[3]+")")},m(t,e){d(t,n,e),a(n,i),a(n,s),a(s,r),m&&m.m(s,null),a(s,l)},p(t,[e]){3&e&&o!==(o=t[1].grid.getTilePath(t[0]))&&f(i,"d",o),64&e&&f(r,"stroke",t[6]),128&e&&f(r,"stroke-width",t[7]),t[12]&&m.p(t,e),32&e&&u!==(u=t[5].color)&&f(l,"stroke",u),35&e&&g(s,"transform","rotate("+t[1].grid.getAngle(t[5].rotations,t[0])+"rad)"),12&e&&p!==(p="translate("+t[2]+","+t[3]+")")&&f(n,"transform",p)},i:t,o:t,d(t){t&&h(n),m&&m.d()}}}function V(t,e,n){let i,o,{i:s}=e,{game:l}=e,{cx:a=0}=e,{cy:d=0}=e,h=l.tileStates[s];r(t,h,(t=>n(5,i=t)));const c=l.disconnectStrokeWidthScale;r(t,c,(t=>n(13,o=t))),l.disconnectStrokeColor;let u="#888",f=l.grid.STROKE_WIDTH,g=2*f+l.grid.PIPE_WIDTH;const p=l.grid.getDirections(i.tile,0,s);l.grid.getGuideDotPosition(i.tile,s);const m=l.grid.PIPE_WIDTH;let _=l.grid.getPipesPath(i.tile,s);const w=1===p.length;return t.$$set=t=>{"i"in t&&n(0,s=t.i),"game"in t&&n(1,l=t.game),"cx"in t&&n(2,a=t.cx),"cy"in t&&n(3,d=t.cy)},t.$$.update=()=>{8226&t.$$.dirty&&(i.hasDisconnects?(n(6,u="#baa660"),n(4,f=l.grid.STROKE_WIDTH*o)):i.isPartOfIsland?(n(6,u="red"),n(4,f=l.grid.STROKE_WIDTH)):(n(6,u="#d3be70"),n(4,f=l.grid.STROKE_WIDTH))),18&t.$$.dirty&&n(7,g=2*f+l.grid.PIPE_WIDTH)},[s,l,a,d,f,i,u,g,h,c,m,_,w,o]}class j extends H{constructor(t){super(),W(this,t,V,B,s,{i:0,game:1,cx:2,cy:3})}}"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;function Q(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var F,Z,J={exports:{}};F=J,Z=J.exports,function(t,e){var n=function(){var t=null,e={};p();var n=[],i=function(e){if(void 0!==(e=e||{}).seed&&null!==e.seed&&e.seed===parseInt(e.seed,10))t=e.seed;else if("string"==typeof e.seed)t=y(e.seed);else{if(void 0!==e.seed&&null!==e.seed)throw new TypeError("The seed value must be an integer or string");t=null}var a,d;if(null!==e.count&&void 0!==e.count){for(var h=e.count,c=[],u=0;u<e.count;u++)n.push(!1);for(e.count=null;h>c.length;){var f=i(e);null!==t&&(e.seed=t),c.push(f)}return e.count=h,c}return l([a=o(e),d=s(a,e),r(a,d,e)],e)};function o(t){if(n.length>0){var e=u(s=M(t.hue)),i=(s[1]-s[0])/n.length,o=parseInt((e-s[0])/i);return!0===n[o]?o=(o+2)%n.length:n[o]=!0,(e=u(s=[(s[0]+o*i)%359,(s[0]+(o+1)*i)%359]))<0&&(e=360+e),e}var s;return(e=u(s=d(t.hue)))<0&&(e=360+e),e}function s(t,e){if("monochrome"===e.hue)return 0;if("random"===e.luminosity)return u([0,100]);var n=h(t),i=n[0],o=n[1];switch(e.luminosity){case"bright":i=55;break;case"dark":i=o-10;break;case"light":o=55}return u([i,o])}function r(t,e,n){var i=a(t,e),o=100;switch(n.luminosity){case"dark":o=i+20;break;case"light":i=(o+i)/2;break;case"random":i=0,o=100}return u([i,o])}function l(t,e){switch(e.format){case"hsvArray":return t;case"hslArray":return w(t);case"hsl":var n=w(t);return"hsl("+n[0]+", "+n[1]+"%, "+n[2]+"%)";case"hsla":var i=w(t),o=e.alpha||Math.random();return"hsla("+i[0]+", "+i[1]+"%, "+i[2]+"%, "+o+")";case"rgbArray":return m(t);case"rgb":return"rgb("+m(t).join(", ")+")";case"rgba":var s=m(t);return o=e.alpha||Math.random(),"rgba("+s.join(", ")+", "+o+")";default:return f(t)}}function a(t,e){for(var n=c(t).lowerBounds,i=0;i<n.length-1;i++){var o=n[i][0],s=n[i][1],r=n[i+1][0],l=n[i+1][1];if(e>=o&&e<=r){var a=(l-s)/(r-o);return a*e+(s-a*o)}}return 0}function d(t){if("number"==typeof parseInt(t)){var n=parseInt(t);if(n<360&&n>0)return[n,n]}if("string"==typeof t)if(e[t]){var i=e[t];if(i.hueRange)return i.hueRange}else if(t.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)){var o=_(t)[0];return[o,o]}return[0,360]}function h(t){return c(t).saturationRange}function c(t){for(var n in t>=334&&t<=360&&(t-=360),e){var i=e[n];if(i.hueRange&&t>=i.hueRange[0]&&t<=i.hueRange[1])return e[n]}return"Color not found"}function u(e){if(null===t){var n=.618033988749895,i=Math.random();return i+=n,i%=1,Math.floor(e[0]+i*(e[1]+1-e[0]))}var o=e[1]||1,s=e[0]||0,r=(t=(9301*t+49297)%233280)/233280;return Math.floor(s+r*(o-s))}function f(t){var e=m(t);function n(t){var e=t.toString(16);return 1==e.length?"0"+e:e}return"#"+n(e[0])+n(e[1])+n(e[2])}function g(t,n,i){var o=i[0][0],s=i[i.length-1][0],r=i[i.length-1][1],l=i[0][1];e[t]={hueRange:n,lowerBounds:i,saturationRange:[o,s],brightnessRange:[r,l]}}function p(){g("monochrome",null,[[0,0],[100,0]]),g("red",[-26,18],[[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]),g("orange",[18,46],[[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]),g("yellow",[46,62],[[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]),g("green",[62,178],[[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]),g("blue",[178,257],[[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]),g("purple",[257,282],[[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]),g("pink",[282,334],[[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]])}function m(t){var e=t[0];0===e&&(e=1),360===e&&(e=359),e/=360;var n=t[1]/100,i=t[2]/100,o=Math.floor(6*e),s=6*e-o,r=i*(1-n),l=i*(1-s*n),a=i*(1-(1-s)*n),d=256,h=256,c=256;switch(o){case 0:d=i,h=a,c=r;break;case 1:d=l,h=i,c=r;break;case 2:d=r,h=i,c=a;break;case 3:d=r,h=l,c=i;break;case 4:d=a,h=r,c=i;break;case 5:d=i,h=r,c=l}return[Math.floor(255*d),Math.floor(255*h),Math.floor(255*c)]}function _(t){t=3===(t=t.replace(/^#/,"")).length?t.replace(/(.)/g,"$1$1"):t;var e=parseInt(t.substr(0,2),16)/255,n=parseInt(t.substr(2,2),16)/255,i=parseInt(t.substr(4,2),16)/255,o=Math.max(e,n,i),s=o-Math.min(e,n,i),r=o?s/o:0;switch(o){case e:return[(n-i)/s%6*60||0,r,o];case n:return[60*((i-e)/s+2)||0,r,o];case i:return[60*((e-n)/s+4)||0,r,o]}}function w(t){var e=t[0],n=t[1]/100,i=t[2]/100,o=(2-n)*i;return[e,Math.round(n*i/(o<1?o:2-o)*1e4)/100,o/2*100]}function y(t){for(var e=0,n=0;n!==t.length&&!(e>=Number.MAX_SAFE_INTEGER);n++)e+=t.charCodeAt(n);return e}function M(t){if(isNaN(t)){if("string"==typeof t)if(e[t]){var n=e[t];if(n.hueRange)return n.hueRange}else if(t.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i))return c(_(t)[0]).hueRange}else{var i=parseInt(t);if(i<360&&i>0)return c(t).hueRange}return[0,360]}return i}();F&&F.exports&&(Z=F.exports=n),Z.randomColor=n}();var tt=Q(J.exports);function et(t){const e={xmin:t.XMIN,ymin:t.YMIN,width:t.XMAX-t.XMIN,height:t.YMAX-t.YMIN},{subscribe:n,set:i,update:o}=G(e);let s,r=null;const l=G([]);return n((e=>{s=e,null===r&&(r=setTimeout((()=>{r=null;const e=t.getVisibleTiles(s);l.set(e)}),100))})),{subscribe:n,set:i,pan:function(e,n){o((i=>function(e){if(t.wrap)return e;let n=e.xmin,i=e.ymin,o=e.width,s=e.height;const r=e.width-(t.XMAX-t.XMIN),l=e.height-(t.YMAX-t.YMIN);return r>0&&l>0?(r<=l?(o=e.width-r,s=e.height-r*e.height/e.width):(s=e.height-l,o=e.width-l*e.width/e.height),n=.5*(t.XMIN+t.XMAX)-o/2,i=.5*(t.YMIN+t.YMAX)-s/2):(r<0&&(n=Math.max(t.XMIN,n),n=Math.min(n,t.XMAX-o)),l<0&&(i=Math.max(t.YMIN,i),i=Math.min(i,t.YMAX-s))),{xmin:n,ymin:i,width:o,height:s}}({xmin:i.xmin-e,ymin:i.ymin-n,width:i.width,height:i.height})))},visibleTiles:{subscribe:l.subscribe}}}function nt(t){let e=this;const{subscribe:n,set:i,update:o}=G(t);return e.data=Object.assign({},t),e.subscribe=n,e.set=function(t){e.data=t,i(t)},e.setColor=function(t){e.data.color=t,i(e.data)},e.toggleLocked=function(){e.data.locked=!e.data.locked,i(e.data)},e.setPartOfLoop=function(t){e.data.isPartOfLoop=t,i(e.data)},e.setPartOfIsland=function(t){e.data.isPartOfIsland=t,i(e.data)},e.setHasDisconnects=function(t){e.data.hasDisconnects=t,i(e.data)},e.rotate=function(t){e.data.rotations+=t,i(e.data)},e}function it(t,e,n){let i=this;i.grid=t,i.tiles=e,i.initialized=!1,i._solved=!1,i.solved=G(!1),i.viewBox=et(t),i.connections=new Map,i.tileStates=[],i.components=new Map,i.openEnds=new Set;const o=t.total-t.emptyCells.size;i.shareDisconnectedTiles=G(1),i.disconnectStrokeWidthScale=G(1),i.disconnectStrokeColor=G("#888888"),i.shareDisconnectedTiles.subscribe((t=>{if(t>.1)return;const e=1-10*t,n=Math.round(136-34*e).toString(16);i.disconnectStrokeColor.set("#"+n+n+n),i.disconnectStrokeWidthScale.set(1+.4*e)}));const s=["empty","empty","empty"];i.tileStates=e.map(((t,e)=>{const n=[...s];return i.grid.wrap||i.grid.EDGEMARK_DIRECTIONS.forEach(((t,o)=>{const{empty:s}=i.grid.find_neighbour(e,t);s&&(n[o]="none")})),new nt({tile:t,rotations:0,color:"white",isPartOfLoop:!1,isPartOfIsland:!1,hasDisconnects:!1,locked:!1,edgeMarks:n})})),i.initializeBoard=function(){i.tileStates.forEach(((e,n)=>{const o=e.data;let s=i.grid.getDirections(o.tile,o.rotations,n);const r=new Set;for(let e of s){const{neighbour:i,empty:o}=t.find_neighbour(n,e);o||r.add(i)}r.size<s.length&&e.setHasDisconnects(!0),i.connections.set(n,r)}));const e=new Set;let n=0;const s=new Set;for(;e.size<i.tileStates.length;){const t=new Set([n]),o={color:i.tileStates[n].data.color,tiles:new Set([n]),openEnds:new Set},r=new Map;let l=!1;for(;t.size>0;){const n=t.values().next().value,a=i.tileStates[n];t.delete(n),e.add(n),i.components.set(n,o),o.tiles.add(n),a.data.hasDisconnects&&(o.openEnds.add(n),i.openEnds.add(n));const d=i.connections.get(n)||s;for(let e of d){const d=r.get(e)||-1;if(d!==n)if((i.connections.get(e)||s).has(n)){if(-1!==d){l=!0;continue}t.add(e),r.set(e,n)}else a.setHasDisconnects(!0),o.openEnds.add(n),i.openEnds.add(n)}}if(l){const t=i.detectLoops(o.tiles);for(let e of t)i.tileStates[e].setPartOfLoop(!0)}if(0===o.openEnds.size)for(let t of o.tiles)i.tileStates[t].setPartOfIsland(!0);for(;e.has(n);)n+=1}i.shareDisconnectedTiles.set(i.openEnds.size/o),i.initialized=!0},i.rotateTile=function(t,e){if(i._solved||0===e)return;const n=i.tileStates[t];if(void 0===n||n.data.locked)return;const o=i.grid.getDirections(n.data.tile,n.data.rotations,t);n.rotate(e);const s=i.grid.getDirections(n.data.tile,n.data.rotations,t),r=o.filter((t=>!s.some((e=>e===t)))),l=s.filter((t=>!o.some((e=>e===t))));i.handleConnections({detail:{tileIndex:t,dirOut:r,dirIn:l}})},i.setTileOrientation=function(t,e,n=!1){const o=i.tileStates[t];if(void 0===o)return;const s=i.tiles[t];let r=s,l=0;for(;r!==e&&l<i.grid.DIRECTIONS.length;)r=i.grid.rotate(r,1,t),l+=1;if(l===i.grid.DIRECTIONS.length)throw`No way to rotate tile at ${t} from ${s} to ${e}`;const a=(l-o.data.rotations)%i.grid.DIRECTIONS.length;(0!==a||n)&&i.rotateTile(t,a||i.grid.DIRECTIONS.length)},i.toggleEdgeMark=function(t,e,n,o=!1){const{neighbour:s,empty:r}=i.grid.find_neighbour(e,n),l=i.grid.EDGEMARK_DIRECTIONS.indexOf(n);if(-1===l){const e=i.grid.OPPOSITE.get(n);return void(!r&&e&&i.toggleEdgeMark(t,s,e,o))}const a=i.tileStates[e];a.data.edgeMarks[l]===t?a.data.edgeMarks[l]="empty":"none"!==a.data.edgeMarks[l]&&(a.data.edgeMarks[l]=t),a.set(a.data),"empty"!==a.data.edgeMarks[l]&&o&&(i.rotateToMatchMarks(e),i.rotateToMatchMarks(s))},i.rotateToMatchMarks=function(e){const n=i.tileStates[e];if(n.data.locked)return;let o=0,s=0;for(let t of i.grid.DIRECTIONS){const{neighbour:r,empty:l}=i.grid.find_neighbour(e,t);if(l){o+=t;continue}if(i.tileStates[r].data.locked){i.connections.get(r)?.has(e)?s+=t:o+=t;continue}const a=i.grid.EDGEMARK_DIRECTIONS.indexOf(t);let d="empty";if(-1===a){const e=i.grid.OPPOSITE.get(t)||0,n=i.grid.EDGEMARK_DIRECTIONS.indexOf(e);d=i.tileStates[r].data.edgeMarks[n]}else d=n.data.edgeMarks[a];"conn"===d?s+=t:"wall"===d&&(o+=t)}for(let r=0;r<t.DIRECTIONS.length;r++){const t=n.data.rotations+r,l=i.grid.rotate(n.data.tile,t,e);if((l&s)===s&&0==(l&o)){i.rotateTile(e,r);break}}},i.handleConnections=function(e){const{tileIndex:n,dirIn:o,dirOut:s}=e.detail,r=i.connections.get(n);if(void 0===r)return;s.forEach((t=>{const{neighbour:e,empty:o}=i.grid.find_neighbour(n,t);if(o)return;r.delete(e);const s=i.connections.get(e);if(void 0===s)throw`Could not find connections data for tile ${e}`;if(!s.has(n))return;const l=i.components.get(e);i.components.get(n)===l&&i.disconnectComponents(n,e),i.setTileDisconnects(e,!0),i.setTileDisconnects(n,!0)}));let l=!1;o.forEach((e=>{const{neighbour:o,empty:s}=t.find_neighbour(n,e);if(s)return l=!0,void i.setTileDisconnects(n,!0);r.add(o);const a=i.connections.get(o);if(void 0===a)throw`Could not find connections data for tile ${o}`;a.has(n)?(i.mergeComponents(n,o),i.setTileDisconnects(o)):l=!0})),l?i.setTileDisconnects(n,!0):i.setTileDisconnects(n),i.initialized&&(i._solved=i.isSolved(),i._solved&&i.solved.set(i._solved))},i.setTileDisconnects=function(t,e=void 0){let n=e||!1;if(void 0===e){const e=i.grid.getDirections(i.tileStates[t].data.tile,0,t),o=i.connections.get(t);if(e.length>o.size)n=!0;else for(let e of o||[])if(!i.connections.get(e)?.has(t)){n=!0;break}}i.tileStates[t].setHasDisconnects(n);const s=i.components.get(t);if(void 0===s)throw`Component open ends data for tile ${t} not found`;if(n){if(0===s.openEnds.size)for(let t of s.tiles)i.tileStates[t].setPartOfIsland(!1);s.openEnds.add(t),i.openEnds.add(t)}else if(s.openEnds.delete(t),i.openEnds.delete(t),0===s.openEnds.size&&s.tiles.size<o)for(let t of s.tiles)i.tileStates[t].setPartOfIsland(!0);i.shareDisconnectedTiles.set(i.openEnds.size/o)};let r=0;for(;i.grid.emptyCells.has(r);)r+=1;return i.isSolved=function(){const t=i.grid.total-i.grid.emptyCells.size,e=i.components.get(r);if(void 0===e)return!1;if(e.tiles.size<t)return!1;let n=r,o=new Set([{fromIndex:-1,tileIndex:n}]);const s=new Set([]);for(;o.size>0;){const t=new Set([]);for(let{fromIndex:e,tileIndex:r}of o){const l=i.connections.get(r);if(void 0===l)throw`Could not find connections data for tile ${r}`;for(let o of l){if(-1===o)return n=r,!1;const l=i.connections.get(o);if(void 0===l)throw`Could not find connections data for tile ${o}`;if(!l.has(r))return n=r,!1;if(o!==e){if(s.has(o))return n=r,!1;t.add({fromIndex:r,tileIndex:o})}}s.add(r),o=t}}return!(s.size<t)},i.mergeComponents=function(t,e){const n=i.components.get(t),o=i.components.get(e);if(void 0===n||void 0===o)return;if(n===o){const t=i.detectLoops(n.tiles);for(let e of n.tiles)i.tileStates[e].setPartOfLoop(t.has(e));return}const s=n.tiles.size>=o.tiles.size,r=s?n:o,l=s?o:n;if(i.initialized){let t=r.color;"white"===t&&(t=l.color),"white"===t&&(t=tt({luminosity:"light"})),r.color!==t&&r.tiles.forEach((e=>{i.tileStates[e].setColor(t)})),r.color=t}for(let t of l.tiles)i.components.set(t,r),r.tiles.add(t),i.tileStates[t].setColor(r.color);for(let t of l.openEnds)r.openEnds.add(t)},i.toggleLocked=function(){return!1},i.disconnectComponents=function(t,e){const n=i.components.get(t);if(void 0===n)return;const o=i.findConnectedTiles(e,t),s=i.findConnectedTiles(t,e);if([...o].some((t=>s.has(t)))){const t=i.detectLoops(n.tiles);for(let e of n.tiles)i.tileStates[e].setPartOfLoop(t.has(e));return}const r=o.size>=s.size?s:o,l={color:tt({luminosity:"light"}),tiles:r,openEnds:new Set([])};for(let t of r)i.components.set(t,l),n.tiles.delete(t),n.openEnds.delete(t)&&l.openEnds.add(t),i.tileStates[t].setColor(l.color)},i.detectLoops=function(t){const e=new Map;let n=new Set;for(let o of t){const s=i.connections.get(o);if(void 0===s)throw`Could not find connections data for tile ${o}`;const r=new Set([...s].filter((e=>{if(!t.has(e))return!1;const n=i.connections.get(e);if(void 0===n)throw`Could not find connections data for tile ${e}`;return n.has(o)})));e.set(o,r),1===r.size&&n.add(o)}function o(t){const n=e.get(t);if(void 0===n)throw`Could not find connections data for tile ${t}`;return n.size<=1?(e.delete(t),n.forEach((n=>{const i=e.get(n);if(void 0===i)throw`Could not find connections data for tile ${n}`;i.delete(t)})),n):new Set}function s(){for(;n.size>0;){const t=n.values().next().value;n.delete(t);o(t).forEach((t=>n.add(t)))}}s();const r=new Set;function l(t,n){let i=[[t,n]];for(;i.length>0;){const n=i.pop();if(void 0===n||0===n.length)throw"Wrong path encountered while tracing loops";const o=n[n.length-1],s=e.get(o);if(void 0===s)throw`Could not find connections data for tile ${o}`;for(let e of s)if(e!==t)n.slice(1).some((t=>t===e))||i.push([...n,e]);else if(n.length>2)return n}return[]}for(;r.size<e.size;){let t=-1;for(let n of e.keys())if(!r.has(n)){t=n;break}const i=e.get(t);if(void 0===i)throw`Could not find connections data for tile ${t}`;const o=i.values().next().value,a=l(t,o);if(0===a.length){i.delete(o);const r=e.get(o);if(void 0===r)throw`Could not find connections data for tile ${o}`;r.delete(t),n.add(o).add(t),s()}else a.forEach((t=>r.add(t)))}return r},i.findConnectedTiles=function(t,e){let n=new Set([{fromIndex:t,tileIndex:e}]);const o=i.components.get(e),s=new Set([]);for(;n.size>0;){const t=new Set([]);for(let{fromIndex:e,tileIndex:r}of n){const l=i.connections.get(r);if(void 0===l)throw`Could not find connections data for tile ${r}`;for(let n of l){if(-1===n)continue;const l=i.components.get(n);if(void 0===l)throw`Could not find component for tile ${n}`;if(l!==o)continue;const a=i.connections.get(n);if(void 0===a)throw`Could not find connections data for tile ${n}`;a.has(r)&&(n!==e&&(s.has(n)||t.add({fromIndex:r,tileIndex:n})))}s.add(r),n=t}}return s},i}class ot{constructor(t,e,n,i=[],o=.01){if(this.num_directions=t,this.angle_offset=e,this.angle_unit=2*Math.PI/t,this.radius_in=n,this.radius_out=n/Math.cos(this.angle_unit/2),this.side_length=2*this.radius_out*Math.sin(this.angle_unit/2),i.length===t)this.directions=[...i];else{if(0!==i.length)throw`Length of directions ${i} does not match directions number ${t}`;this.directions=[...Array(t).keys()].map((t=>2**t))}this.direction_to_index=new Map(this.directions.map(((t,e)=>[t,e]))),this.fully_connected=this.directions.reduce(((t,e)=>t+e),0);let s=e-this.angle_unit/2;const r=this.radius_out-o;this.contour_path=`m ${r*Math.cos(s)} ${-r*Math.sin(s)}`;for(let t=1;t<=this.num_directions;t++)s+=this.angle_unit,this.contour_path+=` L ${r*Math.cos(s)} ${-r*Math.sin(s)}`;this.contour_path+=" z",this.cache={rotate:new Map,pipes_path:new Map,guide_dot_position:new Map,edgemark_line:new Map}}normalize_rotations(t){t%=this.num_directions;const e=this.num_directions/2;return t<=-e?t+=this.num_directions:t>e&&(t-=this.num_directions),t}rotate(t,e){const n=[t,e=this.normalize_rotations(e)].join("_"),i=this.cache.rotate.get(n);if(void 0!==i)return i;let o=0;for(let[n,i]of this.directions.entries()){if(0==(i&t))continue;const s=(n+this.num_directions-e)%this.num_directions;o+=this.directions[s]}return this.cache.rotate.set(n,o),o}get_angle(t){return this.angle_unit*t}get_directions(t,e){let n=t;return 0!==e&&(n=this.rotate(t,e)),this.directions.filter((t=>(t&n)>0))}get_pipes_path(t){const e=this.cache.pipes_path.get(t);if(void 0!==e)return e;let n="M 0 0";return this.directions.forEach(((e,i)=>{if((e&t)>0){const t=this.angle_offset+this.angle_unit*i,e=this.radius_in*Math.cos(t),o=this.radius_in*Math.sin(t);n+=` l ${e} ${-o} L 0 0`}})),this.cache.pipes_path.set(t,n),n}get_guide_dot_position(t){const e=this.cache.guide_dot_position.get(t);if(void 0!==e)return e;let n=0,i=0,o=0;const s=[];for(let[e,r]of this.directions.entries()){if(0==(t&r))continue;o+=1;const l=this.angle_offset+this.angle_unit*e,a={dx:this.radius_in*Math.cos(l),dy:this.radius_in*Math.sin(l),index:e,direction:r,angle:l};n+=a.dx,i+=a.dy,s.push(a)}if(n/=o,i/=o,Math.abs(n)<.001&&Math.abs(i)<.001)if(s.length<=3||s.length===this.num_directions)n=s[0].dx,i=s[0].dy;else{const t=s.map(((t,e,n)=>{const i=n[(e+1)%n.length];return Math.abs(this.normalize_rotations(t.index-i.index))}));if(t.slice(1).every((e=>e===t[0])))n=s[0].dx,i=s[0].dy;else{const e=s.length/2,o=t.map((t=>0));for(let n=0;n<e;n++){const i=this.num_directions**(e-n-1);for(let e of o.keys())o[e]+=i*t[(e+n)%s.length]}const r=Math.min(...o),l=o.indexOf(r);for(let t of s.slice(l,l+e))n+=t.dx,i+=t.dy;n/=e,i/=e}}const r=Math.sqrt(n*n+i*i),l=[this.radius_in*n/r,this.radius_in*i/r];return this.cache.guide_dot_position.set(t,l),l}click_orient_tile(t,e,n){const[i,o]=this.get_guide_dot_position(t),s=Math.atan2(o,i);let r=(Math.round((s-n)/this.angle_unit)-e)%this.num_directions;const l=this.num_directions/2;return r>l?r-=this.num_directions:r<-l&&(r+=this.num_directions),r}detect_edgemark_gesture(t,e,n,i){let o=Math.atan2(n,t),s=Math.atan2(i,e);o+=o<0?2*Math.PI:0,s+=s<0?2*Math.PI:0;let r=Math.abs(o-s),l=.5*(o+s);r>Math.PI&&(r=2*Math.PI-r,l-=Math.PI);const a=Math.round((l-this.angle_offset)/this.angle_unit),d=Math.sqrt(n**2+t**2),h=Math.sqrt(i**2+e**2),c=.5*(d+h),u=Math.abs(c-this.radius_in)<=.4*this.radius_in,f=Math.abs(l-(this.angle_offset+a*this.angle_unit))<=.5*this.angle_unit,g={mark:"none",direction:this.directions[(a+this.num_directions)%this.num_directions]};if(u&&f){const t=this.radius_in*r,e=Math.abs(d-h);t>e?g.mark="wall":t<e&&(g.mark="conn")}return g}is_close_to_edge(t,e){const n=Math.abs(Math.sqrt(t**2+e**2)-this.radius_in);let i=Math.atan2(e,t);i+=i<0?2*Math.PI:0;const o=Math.round((i-this.angle_offset)/this.angle_unit),s=this.angle_offset+this.angle_unit*o;let r=Math.abs(i-s);r=Math.min(r,2*Math.PI-r);return{direction:this.directions[(o+this.num_directions)%this.num_directions],isClose:n<=.3*this.radius_in&&r<=.3*this.angle_unit}}get_edgemark_line(t){const e=this.cache.edgemark_line.get(t);if(void 0!==e)return e;const n=this.direction_to_index.get(t)||0,i=this.angle_offset+n*this.angle_unit,o=Math.cos(i),s=Math.sin(i),r=o*this.radius_in,l=s*this.radius_in,a=.25*this.side_length*o,d=.25*this.side_length*s,h={x1:r-a,y1:-l+d,x2:r+a,y2:-l-d};return this.cache.edgemark_line.set(t,h),h}}const st=16,rt=32,lt=Math.sqrt(3)/2,at=new ot(6,0,.5);class dt{DIRECTIONS=[1,2,4,8,st,rt];EDGEMARK_DIRECTIONS=[2,4,8];OPPOSITE=new Map([[2,st],[st,2],[1,8],[8,1],[4,rt],[rt,4]]);NUM_DIRECTIONS=6;KIND="hexagonal";PIPE_WIDTH=.12;STROKE_WIDTH=.05;PIPE_LENGTH=.5;SINK_RADIUS=.17;emptyCells;total;#t=new Map([[1,[[0,1],[0,1]]],[2,[[-1,0],[-1,1]]],[4,[[-1,-1],[-1,0]]],[8,[[0,-1],[0,-1]]],[st,[[1,-1],[1,0]]],[rt,[[1,0],[1,1]]]]);constructor(t,e,n,i=[]){this.width=t,this.height=e,this.wrap=n,this.emptyCells=new Set,i.forEach(((t,e)=>{0===t&&this.emptyCells.add(e)})),this.total=t*e,this.XMIN=-.6-(n?1:0),this.XMAX=t+.1+(n?1:0),this.YMIN=-lt*(1+(n?1:0)),this.YMAX=lt*(e+(n?1:0)),this.T0=0,this.T1=1,this.T2v=3,this.T2c=5,this.T2I=9,this.T3w=7,this.T3y=11,this.T3la=13,this.T3Y=21,this.T4K=15,this.T4X=27,this.T4psi=23,this.T5=31,this.T6=63,this.tileTypes=new Map;for(let t=0;t<64;t++){let e=t;for(;!this.tileTypes.has(e);)this.tileTypes.set(e,t),e=this.rotate(e,1)}}index_to_xy(t){const e=t%this.width,n=Math.round((t-e)/this.width);return[e+(n%2==0?0:.5),n*lt]}which_tile_at(t,e){const n=e/lt,i=Math.round(n),o=Math.round(t-(i%2==0?0:.5)),s=o+(i%2==0?0:.5),r=i*lt,l=Math.sqrt((t-s)**2+(e-r)**2);if(l<=.5)return{index:this.rc_to_index(i,o),x:s,y:r};{let a=Math.floor(n);a===i&&(a=Math.ceil(n));const d=Math.round(t-(a%2==0?0:.5)),h=d+(a%2==0?0:.5),c=a*lt;return l<Math.sqrt((t-h)**2+(e-c)**2)?{index:this.rc_to_index(i,o),x:s,y:r}:{index:this.rc_to_index(a,d),x:h,y:c}}}find_neighbour(t,e){let n=t%this.width,i=(t-n)/this.width,o=-1;const[s,r]=(this.#t.get(e)||[[]])[i%2];i+=s,n+=r,this.wrap&&(-1==i&&(i=this.height-1,n+=1),i==this.height&&(i=0,n-=1-this.height%2),(n<0||n===this.width)&&(n=(n+this.width)%this.width)),o=i<0||i>=this.height||n<0||n>=this.width?-1:this.width*i+n;return{neighbour:o,empty:-1===o||this.emptyCells.has(o)}}rc_to_index(t,e){if(this.wrap){for(;t<0;){const n=t%2==0;t+=this.height,this.height%2!=0?e+=n?0:1:e+=1}for(;t>=this.height;){const n=t%2==0;t-=this.height,this.height%2!=0?e-=n?1:0:e-=1}(e%=this.width)<0&&(e+=this.width)}else if(t<0||t>=this.height||e<0||e>=this.width)return-1;const n=this.width*t+e;return this.emptyCells.has(n)?-1:n}makeEmpty(t){this.emptyCells.add(t)}fullyConnected(t){return 63}rotate(t,e,n=0){return at.rotate(t,e)}getAngle(t,e){return at.get_angle(t)}getDirections(t,e=0,n=0){return at.get_directions(t,e)}getVisibleTiles(t){let e=Math.floor(t.ymin/lt)-1,n=Math.ceil((t.ymin+t.height)/lt)+1;this.wrap||(e=Math.max(0,e),n=Math.min(this.height-1,n));let i=Math.floor(t.xmin-(e%2==0?0:.5))-1,o=Math.ceil(t.xmin+t.width-(e%2==0?0:.5))+1;this.wrap||(i=Math.max(0,i),o=Math.min(this.width-1,o));const s=[];for(let t=e;t<=n;t++)for(let e=i;e<=o;e++){const n=this.rc_to_index(t,e);if(-1===n)continue;const i=e+(t%2==0?0:.5),o=t*lt,r=`${Math.round(10*i)}_${Math.round(10*o)}`;s.push({index:n,x:i,y:o,key:r})}return s}useShape(t){if("hexagon"===t){const t=this.wrap;this.wrap=!1;const e=Math.floor(this.height/2);let n=this.width*e,i=n+this.width-1;for(let[t,o,s]of[[n,2,8],[i,4,1],[n,rt,8],[i,st,1]]){let n=t;for(let t=1;t<e+1;t++){let t=this.find_neighbour(n,o);if(t.empty)break;n=t.neighbour;let{neighbour:e,empty:i}=this.find_neighbour(n,s);for(;!i;)this.makeEmpty(e),({neighbour:e,empty:i}=this.find_neighbour(e,s))}}this.wrap=t}else if("triangle"===t){const t=this.wrap;this.wrap=!1;let e=0,n=this.width-1;for(let[t,i,o]of[[e,rt,8],[n,st,1]]){let e=t;for(;;){let t=this.find_neighbour(e,i);if(t.empty)break;e=t.neighbour;let{neighbour:n,empty:s}=this.find_neighbour(e,o);for(;!s;)this.makeEmpty(n),({neighbour:n,empty:s}=this.find_neighbour(n,o))}}this.wrap=t}else{if("hourglass"!==t)throw"unknown shape "+t;{console.log("hourglass");const t=this.wrap;this.wrap=!1;const e=Math.floor(this.height/2);for(let[t,n,i]of[[0,rt,8],[this.width-1,st,1],[this.width*(this.height-1),2,8],[this.width*this.height-1,4,1]]){let o=t;for(let t=1;t<e+1;t++){let t=this.find_neighbour(o,n);if(t.empty)break;o=t.neighbour;let{neighbour:e,empty:s}=this.find_neighbour(o,i);for(;!s;)this.makeEmpty(e),({neighbour:e,empty:s}=this.find_neighbour(e,i))}}this.wrap=t}}}getTilePath(t){return at.contour_path}getPipesPath(t,e){return at.get_pipes_path(t)}getGuideDotPosition(t,e=0){const[n,i]=at.get_guide_dot_position(t);return[.8*n,.8*i]}clickOrientTile(t,e,n,i=0){return at.click_orient_tile(t,e,n)}getEdgemarkLine(t,e=0){return at.get_edgemark_line(t)}detectEdgemarkGesture(t,e,n,i,o,s,r){return at.detect_edgemark_gesture(i-e,o-e,n-s,n-r)}whichEdge(t){const{x:e,y:n,tileX:i,tileY:o}=t,s=e-i,r=o-n;return at.is_close_to_edge(s,r)}}function ht(t){this.name="NoOrientationsPossible",this.message=`No orientations possible for tile ${t.initial} at index ${t.index}`}function ct(){this.name="LoopDetected",this.message="Loop detected"}function ut(){this.name="IslandDetected",this.message="Island detected"}function ft(t,e,n){let i=this;if(i.index=e,i.initial=n,i.possible=new Set,n>=0){let o=n;for(;!i.possible.has(o);)i.possible.add(o),o=t.rotate(o,1,e)}else{i.possible=new Set;for(let n=1;n<t.fullyConnected(e);n++)i.possible.add(n)}return i.walls=0,i.connections=0,i.addWall=function(t){i.walls+=t-(i.connections+i.walls&t)},i.addConnection=function(t){i.connections+=t-(i.connections+i.walls&t)},i.mustHaveAllWalls=function(t){for(let e of i.possible)(e&t)>0&&i.possible.delete(e)},i.mustHaveSomeWalls=function(t){for(let e of i.possible)(e&t)===e&&i.possible.delete(e)},i.mustHaveAllConnections=function(t){for(let e of i.possible)(e&t)!==t&&i.possible.delete(e)},i.applyConstraints=function(){const n=new Set;for(let t of i.possible)0==(t&i.walls)&&(t&i.connections)===i.connections&&n.add(t);if(i.possible=n,0===n.size)throw new ht(i);const o=t.fullyConnected(e);let s=o,r=o;n.forEach((t=>{s&=o-t,r&=t}));const l=s-i.walls,a=r-i.connections;return i.walls=s,i.connections=r,{addedWalls:l,addedConnections:a}},i.clone=function(){const e=new ft(t,i.index,0);return e.initial=i.initial,e.possible=new Set(i.possible),e.walls=i.walls,e.connections=i.connections,e},i}function gt(t,e){let n=this;n.tiles=t,n.grid=e,n.UNSOLVED=-1,n.AMBIGUOUS=-2,n.unsolved=new Map([]),n.components=new Map([]),new Set(e.DIRECTIONS),n.solution=t.map((()=>n.UNSOLVED)),n.solutions=[],n.dirty=new Set,n.checkDeadendConnections=n.grid.total>n.grid.DIRECTIONS.length+1,n.getCell=function(t){let e=n.unsolved.get(t);return void 0!==e||(e=new ft(n.grid,t,n.tiles[t]),n.unsolved.set(t,e),n.doLocalDeductions(t,e)),e},n.mergeComponents=function(t,e){const i=n.components.get(t);if(void 0===i)throw"Component to merge is undefined!";const o=n.components.get(e)||new Set([e]);if(i===o)throw new ct;for(let t of o){n.components.set(t,i),i.add(t);const e=n.getCell(t),o=e.walls+e.connections;let s=0;for(let e of n.grid.DIRECTIONS){if((o&e)>0)continue;const r=n.grid.find_neighbour(t,e).neighbour;i.has(r)&&(s+=e)}s>0&&(e.mustHaveAllWalls(s),n.dirty.add(t))}},n.doLocalDeductions=function(t,i){if(1===i.possible.size)return void n.dirty.add(t);const o=n.grid.tileTypes.get(i.initial),s=i.possible.size,r=[],l=e.fullyConnected(t);let a=0,d=0;for(let e of n.grid.DIRECTIONS){if(0==(l&e)){r.push(n.UNSOLVED),d+=e;continue}const{neighbour:i,empty:o}=n.grid.find_neighbour(t,e);o&&(a+=e),r.push(n.grid.tileTypes.get(n.tiles[i])||n.UNSOLVED)}if(a>0&&(i.addWall(a),i.mustHaveAllWalls(a)),d>0&&i.mustHaveAllWalls(d),n.checkDeadendConnections){let t=0;for(let[e,i]of r.entries())i===n.grid.T1&&(t+=n.grid.DIRECTIONS[e]);i.mustHaveSomeWalls(t)}if(n.grid instanceof dt){if([n.grid.T4K,n.grid.T3w,n.grid.T5,n.grid.T4psi].some((t=>t===o)))for(let[t,e]of r.entries())if([n.grid.T4K,n.grid.T2v,n.grid.T3w,n.grid.T5,n.grid.T4X].some((t=>t===e))){const e=n.grid.DIRECTIONS[t],o=e+n.grid.rotate(e,1)+n.grid.rotate(e,-1);i.mustHaveSomeWalls(o)}if([n.grid.T4psi,n.grid.T4X,n.grid.T5,n.grid.T3Y].some((t=>t===o)))for(let[t,e]of r.entries())if([n.grid.T4psi,n.grid.T4X,n.grid.T5,n.grid.T3Y].some((t=>t===e))){const e=n.grid.DIRECTIONS[t];i.mustHaveAllConnections(e)}if([n.grid.T4psi,n.grid.T4X,n.grid.T5,n.grid.T3Y].every((t=>t!==o)))for(let[t,e]of r.entries())if([n.grid.T4psi,n.grid.T4X,n.grid.T5,n.grid.T3Y].some((t=>t===e))){const e=n.grid.DIRECTIONS[t];let o=0;if([n.grid.T1,n.grid.T2c,n.grid.T2I].some((e=>e===r[(t+1)%6]))&&(o+=n.grid.DIRECTIONS[(t+1)%6]),[n.grid.T1,n.grid.T2c,n.grid.T2I].some((e=>e===r[(t+5)%6]))&&(o+=n.grid.DIRECTIONS[(t+5)%6]),0===o)continue;for(let t of i.possible)(t&o)>0&&0==(t&e)&&i.possible.delete(t)}}i.possible.size<s&&n.dirty.add(t)},n.processDirtyCells=function*(){for(;n.dirty.size>0;){const t=n.dirty.keys().next().value,e=n.getCell(t);if(void 0===e)continue;const{addedWalls:i,addedConnections:o}=e.applyConstraints();if(o>0&&!n.components.has(t)&&n.components.set(t,new Set([t])),i>0)for(let e of n.grid.DIRECTIONS)if((e&i)>0){const{neighbour:i,empty:o}=n.grid.find_neighbour(t,e);if(o)continue;n.getCell(i).addWall(n.grid.OPPOSITE.get(e)||0),n.dirty.add(i)}if(o>0)for(let e of n.grid.DIRECTIONS)if((e&o)>0){const{neighbour:i,empty:o}=n.grid.find_neighbour(t,e);if(o)throw"Trying to connect to an empty neighbour!";n.getCell(i).addConnection(n.grid.OPPOSITE.get(e)||0),n.mergeComponents(t,i),n.dirty.add(i)}const s=e.possible.keys().next().value,r=1===e.possible.size;if(r){const e=n.components.get(t);if(void 0!==e&&(e.delete(t),0===e.size&&n.unsolved.size>1))throw new ut;n.solution[t]=s,n.unsolved.delete(t),n.components.delete(t)}yield{index:t,orientation:s,final:r},n.dirty.delete(t)}},n.clone=function(){const t=new gt([],n.grid);return t.unsolved=new Map([]),n.unsolved.forEach(((e,n)=>{t.unsolved.set(n,e.clone())})),t.components=new Map([]),n.components.forEach(((e,n)=>{const i=new Set(e);for(let e of i){if(t.components.has(e))break;t.components.set(e,i)}})),t.solution=[...n.solution],t.dirty=new Set,t},n.makeAGuess=function(){let t=Number.POSITIVE_INFINITY,e=-1;for(let[i,o]of n.unsolved.entries())if(o.possible.size<t&&(e=i,t=o.possible.size,2==t))break;const i=n.unsolved.get(e);if(void 0===i)throw"Cell selected for guessing is undefined!";const o=i.possible.keys().next().value;return i.possible=new Set([o]),n.dirty.add(e),[e,o]},n.solve=function*(t=!1){if(0===n.dirty.size){const t=new Set;for(let i=0;i<e.total;i++)e.emptyCells.has(i)?n.dirty.add(i):t.add(i);for(;t.size>0;){const e=t.values().next().value;if(t.delete(e),!n.unsolved.has(e)){n.dirty.add(e);for(let e of n.processDirtyCells())t.delete(e.index),0!==e.orientation&&(yield{stage:"initial",step:e})}}}const i=[{index:-1,guess:-1,solver:n}];for(;i.length>0;){const e=i[i.length-1];if(void 0===e)break;const{index:o,guess:s,solver:r}=e;try{let t=1===i.length?"initial":"guess";t=0===n.solutions.length?t:"aftercheck";for(let e of r.processDirtyCells())yield{stage:t,step:e}}catch(t){if(i.length>1){i.pop();const t=i[i.length-1].solver,e=t.unsolved.get(o);e?.possible.delete(s),t.dirty.add(o);continue}break}if(0==r.unsolved.size){if(n.solution=r.solution,n.solutions.push([...r.solution]),!t)break;if(i.length>1){i.pop();const t=i[i.length-1].solver,e=t.unsolved.get(o);e?.possible.delete(s),t.dirty.add(o);continue}break}{const t=r.clone(),[e,n]=t.makeAGuess();i.push({index:e,guess:n,solver:t})}}},n.markAmbiguousTiles=function(){let t=[...n.solution],i=!0;try{if(0===n.dirty.size){const i=new Set;for(let t=0;t<e.total;t++)e.emptyCells.has(t)?n.dirty.add(t):i.add(t);for(;i.size>0;){const e=i.values().next().value;if(i.delete(e),!n.unsolved.has(e)){n.dirty.add(e);for(let e of n.processDirtyCells())i.delete(e.index),e.final&&(t[e.index]=e.orientation)}}}}catch(e){return{marked:t,solvable:!1,unique:!1}}const o=[{index:-1,guess:-1,solver:n}];for(;o.length>0;){const e=o[o.length-1];if(void 0===e)break;const{index:s,guess:r,solver:l}=e;try{for(let t of l.processDirtyCells());}catch(t){if(o.length>1){o.pop();const t=o[o.length-1].solver,e=t.unsolved.get(s);e?.possible.delete(r),t.dirty.add(s);continue}break}if(0==l.unsolved.size){for(let e=0;e<t.length;e++)t[e]===n.UNSOLVED?t[e]=l.solution[e]:t[e]===n.AMBIGUOUS||t[e]!==l.solution[e]&&(t[e]=n.AMBIGUOUS,i=!1);if(o.length>1){o.pop();const t=o[o.length-1].solver,e=t.unsolved.get(s);e?.possible.delete(r),t.dirty.add(s);continue}break}{const e=l.clone();let i=Number.POSITIVE_INFINITY,s=-1;for(let[o,r]of e.unsolved.entries())if(t[o]!==n.AMBIGUOUS&&r.possible.size<i&&(s=o,i=r.possible.size,2==i))break;const r=e.unsolved.get(s);if(void 0===r){l.unsolved=new Map;continue}const a=r.possible.keys().next().value;r.possible=new Set([a]),e.dirty.add(s),o.push({index:s,guess:a,solver:e})}}const s=t.every((t=>t!==n.UNSOLVED));return{marked:t,solvable:s,unique:i}}}function pt(t,e,n){const i=t.slice();return i[11]=e[n],i[13]=n,i}function mt(t,e){let n,i,o;return i=new j({props:{i:e[11].index,game:e[1],cx:e[11].x,cy:e[11].y}}),{key:t,first:null,c(){n=u(),z(i.$$.fragment),this.first=n},m(t,e){d(t,n,e),X(i,t,e),o=!0},p(t,n){e=t;const o={};8&n&&(o.i=e[11].index),2&n&&(o.game=e[1]),8&n&&(o.cx=e[11].x),8&n&&(o.cy=e[11].y),i.$set(o)},i(t){o||(P(i.$$.fragment,t),o=!0)},o(t){R(i.$$.fragment,t),o=!1},d(t){t&&h(n),L(i,t)}}}function _t(e){let n,s,r,l,u,g,m,_=[],w=new Map,y=e[3];const M=t=>t[11].key;for(let t=0;t<y.length;t+=1){let n=pt(e,y,t),i=M(n);w.set(i,_[t]=mt(i,n))}return{c(){var t;t="div",n=document.createElement(t),s=c("svg");for(let t=0;t<_.length;t+=1)_[t].c();f(s,"width","490"),f(s,"height","490"),f(s,"viewBox",r=e[2].xmin+" "+e[2].ymin+" "+e[2].width+" "+e[2].height),f(s,"class","svelte-1ektuee"),f(n,"class","puzzle animation-normal svelte-1ektuee"),p(n,"solved",e[0])},m(i,r){d(i,n,r),a(n,s);for(let t=0;t<_.length;t+=1)_[t]&&_[t].m(s,null);var h,c,f,p,w,y;u=!0,g||(m=[(y=l=q.call(null,s,e[1]),y&&o(y.destroy)?y.destroy:t),(h=s,c="contextmenu",w=wt,f=function(t){return t.preventDefault(),w.call(this,t)},h.addEventListener(c,f,p),()=>h.removeEventListener(c,f,p))],g=!0)},p(t,[e]){10&e&&(y=t[3],O(),_=function(t,e,n,o,s,r,l,a,d,h,c,u){let f=t.length,g=r.length,p=f;const m={};for(;p--;)m[t[p].key]=p;const _=[],w=new Map,y=new Map,M=[];for(p=g;p--;){const t=u(s,r,p),i=n(t);let a=l.get(i);a?o&&M.push((()=>a.p(t,e))):(a=h(i,t),a.c()),w.set(i,_[p]=a),i in m&&y.set(i,Math.abs(p-m[i]))}const b=new Set,v=new Set;function T(t){P(t,1),t.m(a,c),l.set(t.key,t),c=t.first,g--}for(;f&&g;){const e=_[g-1],n=t[f-1],i=e.key,o=n.key;e===n?(c=e.first,f--,g--):w.has(o)?!l.has(i)||b.has(i)?T(e):v.has(o)?f--:y.get(i)>y.get(o)?(v.add(i),T(e)):(b.add(o),f--):(d(n,l),f--)}for(;f--;){const e=t[f];w.has(e.key)||d(e,l)}for(;g;)T(_[g-1]);return i(M),_}(_,e,M,1,t,y,w,s,A,mt,null,pt),N()),(!u||4&e&&r!==(r=t[2].xmin+" "+t[2].ymin+" "+t[2].width+" "+t[2].height))&&f(s,"viewBox",r),l&&o(l.update)&&2&e&&l.update.call(null,t[1]),(!u||1&e)&&p(n,"solved",t[0])},i(t){if(!u){for(let t=0;t<y.length;t+=1)P(_[t]);u=!0}},o(t){for(let t=0;t<_.length;t+=1)R(_[t]);u=!1},d(t){t&&h(n);for(let t=0;t<_.length;t+=1)_[t].d();g=!1,i(m)}}}const wt=()=>{};function yt(t,e,n){let i,o,s,{grid:a}=e,{tiles:d=[]}=e,{savedProgress:h}=e,{animate:c=!1}=e,u=new it(a,d),f=u.solved;r(t,f,(t=>n(0,i=t)));const g=u.viewBox;r(t,g,(t=>n(2,o=t))),l(g,o.width=Math.min(a.XMAX-a.XMIN,10),o),l(g,o.height=Math.min(a.YMAX-a.YMIN,10),o);const p=g.visibleTiles;return r(t,p,(t=>n(3,s=t))),w((()=>{u.initializeBoard()})),window.autoSolve=async function(){let t;function e(t=-1){return new Promise((e=>setTimeout(e,t)))}if(i)return new Promise((t=>{t()}));for(let t of u.tileStates)t.data.locked&&t.toggleLocked();t=new gt(d,a);try{for(let{stage:n,step:i}of t.solve(!0)){if("aftercheck"===n)continue;u.toggleLocked(i.index,!1);const t=i.final&&"initial"===n;u.setTileOrientation(i.index,i.orientation,!t),t&&u.toggleLocked(i.index,!0),c&&await e(200)}if(t.solutions.length>1){u.solved.set(!1),n(1,u._solved=!1,u);for(let[e,n]of t.solutions[0].entries()){const i=t.solutions.every((t=>t[e]===n));u.tileStates[e].data.locked!==i&&u.tileStates[e].toggleLocked()}}}catch(t){console.error(t)}},t.$$set=t=>{"grid"in t&&n(7,a=t.grid),"tiles"in t&&n(8,d=t.tiles),"savedProgress"in t&&n(9,h=t.savedProgress),"animate"in t&&n(10,c=t.animate)},t.$$.update=()=>{1&t.$$.dirty&&i&&(console.log('"window.onPuzzleSovled()" has been called'),window.onPuzzleSolved())},[i,u,o,s,f,g,p,a,d,h,c]}class Mt extends H{constructor(t){super(),W(this,t,yt,_t,s,{grid:7,tiles:8,savedProgress:9,animate:10})}}const bt=new ot(4,0,.5);class vt{DIRECTIONS=[1,2,4,8];EDGEMARK_DIRECTIONS=[2,4];OPPOSITE=new Map([[2,8],[8,2],[1,4],[4,1]]);XY_DELTAS=new Map([[2,[0,1]],[8,[0,-1]],[1,[1,0]],[4,[-1,0]]]);NUM_DIRECTIONS=4;KIND="square";PIPE_WIDTH=.15;STROKE_WIDTH=.06;PIPE_LENGTH=.5;SINK_RADIUS=.2;emptyCells;total;constructor(t,e,n,i=[]){this.width=t,this.height=e,this.wrap=n,this.emptyCells=new Set,i.forEach(((t,e)=>{0===t&&this.emptyCells.add(e)})),this.total=t*e,this.XMIN=-.6-(n?1:0),this.XMAX=t-.4+(n?1:0),this.YMIN=-(1+(n?1:0)),this.YMAX=e+(n?1:0),this.T0=0,this.T1=1,this.T2L=3,this.T2I=5,this.T3=7,this.tileTypes=new Map;for(let t=0;t<16;t++){let e=t;for(;!this.tileTypes.has(e);)this.tileTypes.set(e,t),e=this.rotate(e,1)}}index_to_xy(t){const e=t%this.width;return[e,Math.round((t-e)/this.width)]}which_tile_at(t,e){const n=Math.round(t),i=Math.round(e);let o=this.rc_to_index(i,n);return this.emptyCells.has(o)&&(o=-1),{index:o,x:n,y:i}}find_neighbour(t,e){let n=t%this.width,i=(t-n)/this.width,o=-1;const[s,r]=this.XY_DELTAS.get(e)||[0,0];i-=r,n+=s,o=this.rc_to_index(i,n);return{neighbour:o,empty:-1===o||this.emptyCells.has(o)}}rc_to_index(t,e){if(this.wrap)(t%=this.height)<0&&(t+=this.height),(e%=this.width)<0&&(e+=this.width);else{if(t<0||t>=this.height)return-1;if(e<0||e>=this.width)return-1}return this.width*t+e}makeEmpty(t){this.emptyCells.add(t)}fullyConnected(t){return 15}rotate(t,e,n=0){return bt.rotate(t,e)}getAngle(t,e){return bt.get_angle(t)}getDirections(t,e=0){return bt.get_directions(t,e)}getVisibleTiles(t){let e=Math.floor(t.ymin)-1,n=Math.ceil(t.ymin+t.height)+1;this.wrap||(e=Math.max(0,e),n=Math.min(this.height-1,n));let i=Math.floor(t.xmin)-1,o=Math.ceil(t.xmin+t.width)+1;this.wrap||(i=Math.max(0,i),o=Math.min(this.width-1,o));const s=[];for(let t=e;t<=n;t++)for(let e=i;e<=o;e++){const n=this.rc_to_index(t,e);if(-1===n)continue;const i=e,o=t,r=`${Math.round(i)}_${Math.round(o)}`;s.push({index:n,x:i,y:o,key:r})}return s}getTilePath(t){return bt.contour_path}getPipesPath(t,e){return bt.get_pipes_path(t)}getGuideDotPosition(t,e){const[n,i]=bt.get_guide_dot_position(t);return[.8*n,.8*i]}clickOrientTile(t,e,n,i=0){return bt.click_orient_tile(t,e,n)}getEdgemarkLine(t,e=0){return bt.get_edgemark_line(t)}detectEdgemarkGesture(t,e,n,i,o,s,r){return bt.detect_edgemark_gesture(i-e,o-e,n-s,n-r)}whichEdge(t){const{x:e,y:n,tileX:i,tileY:o}=t,s=e-i,r=o-n;return bt.is_close_to_edge(s,r)}}const Tt=1,It=4,xt=16,St=64,kt=128,Et=(.5-.5*Math.sin(Math.PI/8))*Math.SQRT2/2,Ct=new ot(8,0,.5),Dt=new ot(4,Math.PI/4,Et,[2,8,32,128]);class $t{DIRECTIONS=[Tt,2,It,8,xt,32,St,kt];EDGEMARK_DIRECTIONS=[2,It,8,xt];OPPOSITE=new Map([[It,St],[St,It],[Tt,xt],[xt,Tt],[2,32],[32,2],[8,kt],[kt,8]]);RC_DELTAS=new Map([[Tt,[1,0]],[2,[.5,.5]],[It,[0,1]],[8,[-.5,.5]],[xt,[-1,0]],[32,[-.5,-.5]],[St,[0,-1]],[kt,[.5,-.5]]]);XY_DELTAS=new Map([[Tt,[1,0]],[2,[Math.SQRT1_2,Math.SQRT1_2]],[It,[0,1]],[8,[-Math.SQRT1_2,Math.SQRT1_2]],[xt,[-1,0]],[32,[-Math.SQRT1_2,-Math.SQRT1_2]],[St,[0,-1]],[kt,[Math.SQRT1_2,-Math.SQRT1_2]]]);ANGLE_DEG=45;ANGLE_RAD=Math.PI/4;NUM_DIRECTIONS=8;KIND="octagonal";PIPE_WIDTH=.1;STROKE_WIDTH=.04;PIPE_LENGTH=.5;SINK_RADIUS=.13;emptyCells;total;constructor(t,e,n,i=[]){if(this.width=t,this.height=e,this.wrap=n,this.emptyCells=new Set,i.forEach(((t,e)=>{0===t&&this.emptyCells.add(e)})),0===i.length&&!n){const n=2*t*e;for(let e=1;e<=t;e++)this.emptyCells.add(n-e);for(let i=1;i<e;i++)this.emptyCells.add(n-1-t*i)}this.total=2*t*e,this.XMIN=-.6-(n?1:0),this.XMAX=t-.4+(n?1:0),this.YMIN=-(1+(n?1:0)),this.YMAX=e+(n?1:0),this.T0=0,this.T1=1,this.T2v=3,this.T2L=5,this.T2C=9,this.T2I=17,this.T3w=7,this.tileTypes=new Map;for(let t=0;t<256;t++){let e=t;for(;!this.tileTypes.has(e);)this.tileTypes.set(e,t),e=this.rotate(e,1)}}index_to_xy(t){const e=t>=this.width*this.height,n=t-(e?this.width*this.height:0),i=n%this.width;return[i+(e?.5:0),Math.round((n-i)/this.width)+(e?.5:0)]}which_tile_at(t,e){const n=.5*(Math.floor(t)+Math.ceil(t)),i=Math.round(t),o=.5*(Math.floor(e)+Math.ceil(e)),s=Math.round(e),r=.5*(1-Math.sin(Math.PI/8));if(Math.abs(t-n)+Math.abs(e-o)<=r){let t=this.rc_to_index(o,n);return this.emptyCells.has(t)&&(t=-1),{index:t,x:n,y:o}}let l=this.rc_to_index(s,i);return this.emptyCells.has(l)&&(l=-1),{index:l,x:i,y:s}}find_neighbour(t,e){let n=0,i=0;if(t>=this.width*this.height){if([It,St,Tt,xt].some((t=>t===e)))return{neighbour:-1,empty:!0};t-=this.width*this.height,n+=.5,i+=.5}n+=t%this.width,i+=(t-t%this.width)/this.width;let o=-1;const[s,r]=this.RC_DELTAS.get(e)||[0,0];i-=r,n+=s,o=this.rc_to_index(i,n);return{neighbour:o,empty:-1===o||this.emptyCells.has(o)}}rc_to_index(t,e){let n=0;if(t-Math.floor(t)>.2&&(n=this.width*this.height,t=Math.floor(t),e=Math.floor(e)),this.wrap)(t%=this.height)<0&&(t+=this.height),(e%=this.width)<0&&(e+=this.width);else{if(t<0||t>=this.height)return-1;if(e<0||e>=this.width)return-1}return this.width*t+e+n}makeEmpty(t){this.emptyCells.add(t)}getVisibleTiles(t){let e=Math.floor(t.ymin)-1,n=Math.ceil(t.ymin+t.height)+1;this.wrap||(e=Math.max(0,e),n=Math.min(this.height-1,n));let i=Math.floor(t.xmin)-1,o=Math.ceil(t.xmin+t.width)+1;this.wrap||(i=Math.max(0,i),o=Math.min(this.width-1,o));const s=[];for(let t=e;t<=n;t++){for(let e=i;e<=o;e++){const n=this.rc_to_index(t,e);if(-1!==n&&!this.emptyCells.has(n)){const i=e,o=t,r=`${Math.round(2*i)}_${Math.round(2*o)}`;s.push({index:n,x:i,y:o,key:r})}}const e=t+.5;for(let t=i;t<=o;t++){const n=t+.5,i=this.rc_to_index(e,n);if(-1!==i&&!this.emptyCells.has(i)){const t=n,o=e,r=`${Math.round(2*t)}_${Math.round(2*o)}`;s.push({index:i,x:t,y:o,key:r})}}}return s}#e(t){return t>=this.width*this.height?Dt:Ct}fullyConnected(t){return this.#e(t).fully_connected}rotate(t,e,n=0){return this.#e(n).rotate(t,e)}getAngle(t,e){return this.#e(e).get_angle(t)}getDirections(t,e=0,n){return this.#e(n).get_directions(t,e)}getTilePath(t){return this.#e(t).contour_path}getPipesPath(t,e){return this.#e(e).get_pipes_path(t)}getGuideDotPosition(t,e=0){const[n,i]=this.#e(e).get_guide_dot_position(t);return[.7*n,.7*i]}clickOrientTile(t,e,n,i=0){return this.#e(i).click_orient_tile(t,e,n)}getEdgemarkLine(t,e=0){return this.#e(e).get_edgemark_line(t)}detectEdgemarkGesture(t,e,n,i,o,s,r){return this.#e(t).detect_edgemark_gesture(i-e,o-e,n-s,n-r)}whichEdge(t){const{x:e,y:n,tileX:i,tileY:o,tileIndex:s}=t,r=e-i,l=o-n;return this.#e(s).is_close_to_edge(r,l)}}function Ot(t){return t[Math.floor(Math.random()*t.length)]}function Nt(t,e){const n=e.DIRECTIONS.length;return t.map(((t,i)=>{if(0===t)return 0;return e.rotate(t,Math.floor(Math.random()*n),i)}))}new dt(3,3,!1),new vt(3,3,!1),new $t(3,3,!1);class Pt{constructor(t){this.grid=t}pregenerate_growingtree(t,e=0,n=0,i=[]){const o=this.grid.total,s=new Set([...Array(o).keys()]);for(let t of this.grid.emptyCells)s.delete(t);const r=[];for(let t=0;t<o;t++)r.push(0);const l=[],a=[],d=[];if(i.length===o){const t=new Set(s),e=[];for(;t.size>0;){const n=t.values().next().value;if(t.delete(n),i[n]<0)continue;const o=new Set([n]),s=new Set;for(;o.size>0;){const e=o.values().next().value;o.delete(e),t.delete(e),s.add(e);for(let t of this.grid.getDirections(i[e],0,e)){const{neighbour:n,empty:r}=this.grid.find_neighbour(e,t);r||i[n]<0||s.has(n)||o.add(n)}}if(e.push(s),e.sort(((t,e)=>-(t.size-e.size))),e[0].size>=t.size)break}for(let t of e[0]||[]){for(let n of this.grid.getDirections(i[t],0,t)){const{neighbour:i}=this.grid.find_neighbour(t,n);e[0].has(i)&&(r[t]+=n)}l.push(t),s.delete(t)}}const h=new Map,c=new Map;if(e>0){for(let t of s)for(let e of this.grid.DIRECTIONS){const{neighbour:n,empty:i}=this.grid.find_neighbour(t,e);i&&h.set(t,(h.get(t)||0)+e)}for(let t of new Set(h.values())){let e=new ft(this.grid,0,-1);e.addWall(t),e.applyConstraints();const n=new Map;for(let t of e.possible){const e=this.grid.tileTypes.get(t)||0;n.has(e)||n.set(e,new Set),n.get(e)?.add(t)}for(let[e,i]of n.entries())1===i.size&&(c.has(t)||c.set(t,new Set),c.get(t)?.add(i.values().next().value))}}if(0===l.length){const t=[...s][Math.floor(Math.random()*s.size)];l.push(t),s.delete(t)}for(;s.size>0;){let i=0;const o=Math.random()<t;for(let t of[l,a,d])if(0!==t.length){i=o?Ot(t):t[t.length-1];break}if(void 0===i)throw"Error in pregeneration: fromNode is undefined";const u=[],f=[],g=[],p=[],m=r[i];for(let t of this.grid.DIRECTIONS){if((t&m)>0)continue;const{neighbour:o,empty:l}=this.grid.find_neighbour(i,t);if(!l&&s.has(o))if(m+t!==this.grid.fullyConnected(i)){if(h.has(i)&&Math.random()<e){const e=h.get(i)||0,n=c.get(e);if(n?.has(r[i]+t)){g.push({neighbour:o,direction:t});continue}}this.grid.tileTypes.get(m+t)===this.grid.T2I&&Math.random()<n?f.push({neighbour:o,direction:t}):u.push({neighbour:o,direction:t})}else p.push({neighbour:o,direction:t})}let _=null,w=null;for(let t of[u,f,g,p])if(t.length>0){w=t,_=Ot(t);break}if(null!==_)if(w===p&&l.length>0){const t=l.indexOf(i);l.splice(t,1),d.push(i)}else if(w===g&&l.length>0){const t=l.indexOf(i);l.splice(t,1),a.push(i)}else r[i]+=_.direction,r[_.neighbour]+=this.grid.OPPOSITE.get(_.direction)||0,s.delete(_.neighbour),l.push(_.neighbour);else{const t=[l,a,d].find((t=>t.length>0))||[];if(o){const e=t.indexOf(i);t.splice(e,1)}else t.pop()}}return r}generate(t=.6,e=0,n=0){let i=0;for(;i<3;){i+=1;let o=this.pregenerate_growingtree(t,e,n),s=0;for(;s<10;){s+=1;const i=new gt(o,this.grid),{marked:r,unique:l}=i.markAmbiguousTiles();if(l)return Nt(r,this.grid);o=this.pregenerate_growingtree(t,e,n,r)}}}}function Rt(e){let n,i,o=e[3],r=At(e);return{c(){r.c(),n=u()},m(t,e){r.m(t,e),d(t,n,e),i=!0},p(e,i){8&i&&s(o,o=e[3])?(O(),R(r,1,1,t),N(),r=At(e),r.c(),P(r,1),r.m(n.parentNode,n)):r.p(e,i)},i(t){i||(P(r),i=!0)},o(t){R(r),i=!1},d(t){t&&h(n),r.d(t)}}}function At(t){let e,n,i={grid:t[1],tiles:t[2],animate:!0};return e=new Mt({props:i}),t[5](e),e.$on("solved",t[6]),{c(){z(e.$$.fragment)},m(t,i){X(e,t,i),n=!0},p(t,n){const i={};2&n&&(i.grid=t[1]),4&n&&(i.tiles=t[2]),e.$set(i)},i(t){n||(P(e.$$.fragment,t),n=!0)},o(t){R(e.$$.fragment,t),n=!1},d(n){t[5](null),L(e,n)}}}function zt(t){let e,n,i=t[3]>0&&Rt(t);return{c(){i&&i.c(),e=u()},m(t,o){i&&i.m(t,o),d(t,e,o),n=!0},p(t,[n]){t[3]>0?i?(i.p(t,n),8&n&&P(i,1)):(i=Rt(t),i.c(),P(i,1),i.m(e.parentNode,e)):i&&(O(),R(i,1,1,(()=>{i=null})),N())},i(t){n||(P(i),n=!0)},o(t){R(i),n=!1},d(t){i&&i.d(t),t&&h(e)}}}function Xt(t,e,n){let i,o,s=!1,r=[],l=0;window.generate=function(t="square",e=4){["square","hexagonal","octagonal"].includes(t)?(n(3,l+=1),n(1,i=function(t,e,n,i,o){let s;if("hexagonal"===t)s=new dt(e,n,i,o);else if("octagonal"===t)s=new $t(e,n,i,o);else{if("square"!==t)throw`Unknown grid kind ${t}`;s=new vt(e,n,i,o)}return s}(t,e,e,!1)),n(2,r=new Pt(i).generate())):console.log("Puzzle URL ")},w((()=>{if(window.location.search){let t=window.location.href.split("?")[1].split("&");window.generate(t[0].split("=")[1],parseInt(t[1].split("=")[1]))}else window.generate()}));return[s,i,r,l,o,function(t){M[t?"unshift":"push"]((()=>{o=t,n(4,o)}))},()=>n(0,s=!0)]}return new class extends H{constructor(t){super(),W(this,t,Xt,zt,s,{})}}({target:document.body,props:{name:""}})}();
//# sourceMappingURL=bundle.js.map
