{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/svelte/store/index.mjs","../../src/lib/stores.js","../../src/lib/puzzle/controls.js","../../src/lib/puzzle/Tile.svelte","../../node_modules/randomcolor/randomColor.js","../../src/lib/puzzle/viewbox.js","../../src/lib/puzzle/game.js","../../src/lib/puzzle/grids/polygonutils.js","../../src/lib/puzzle/grids/hexagrid.js","../../src/lib/puzzle/solver.js","../../src/lib/puzzle/Puzzle.svelte","../../src/lib/puzzle/grids/squaregrid.js","../../src/lib/puzzle/grids/octagrid.js","../../src/lib/puzzle/generator.js","../../src/lib/puzzle/grids/grids.js","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\nfunction split_css_unit(value) {\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\n}\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction comment(content) {\n    return document.createComment(content);\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction set_dynamic_element_data(tag) {\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction init_binding_group(group) {\n    let _inputs;\n    return {\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            _inputs.forEach(input => group.push(input));\n        },\n        /* remove */ r() {\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n        }\n    };\n}\nfunction init_binding_group_dynamic(group, indexes) {\n    let _group = get_binding_group(group);\n    let _inputs;\n    function get_binding_group(group) {\n        for (let i = 0; i < indexes.length; i++) {\n            group = group[indexes[i]] = group[indexes[i]] || [];\n        }\n        return group;\n    }\n    function push() {\n        _inputs.forEach(input => _group.push(input));\n    }\n    function remove() {\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n    }\n    return {\n        /* update */ u(new_indexes) {\n            indexes = new_indexes;\n            const new_group = get_binding_group(group);\n            if (new_group !== _group) {\n                remove();\n                _group = new_group;\n                push();\n            }\n        },\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            push();\n        },\n        /* remove */ r: remove\n    };\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction claim_comment(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\n        node.data = '' + data;\n        return undefined;\n    }, () => comment(data), true);\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    text.data = data;\n}\nfunction set_data_contenteditable(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable(text, data);\n    }\n    else {\n        set_data(text, data);\n    }\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value === null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    if (!mounting || value !== undefined) {\n        select.selectedIndex = -1; // no option should be selected\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked');\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n            // see https://github.com/sveltejs/svelte/issues/4233\n            fn();\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\n            else\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n */\nfunction flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            // defer updates until all the DOM shuffling is done\n            updates.push(() => block.p(child_ctx, dirty));\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst _boolean_attributes = [\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n];\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n */\nconst boolean_attributes = new Set([..._boolean_attributes]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        flush_render_callbacks($$.after_update);\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.58.0' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    if (has_stop_immediate_propagation)\n        modifiers.push('stopImmediatePropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_contenteditable_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable_dev(text, data);\n    }\n    else {\n        set_data_dev(text, data);\n    }\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, init_binding_group, init_binding_group_dynamic, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, split_css_unit, spread, src_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0 && stop) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let started = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (started) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        started = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n            // We need to set this to false because callbacks can still happen despite having unsubscribed:\n            // Callbacks might already be placed in the queue which doesn't know it should no longer\n            // invoke this derived store.\n            started = false;\n        };\n    });\n}\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * @param store - store to make readonly\n */\nfunction readonly(store) {\n    return {\n        subscribe: store.subscribe.bind(store)\n    };\n}\n\nexport { derived, readable, readonly, writable };\n","import { writable } from 'svelte/store';\n\n\nfunction createSettings() {\n\tlet defaultSettings = {\n\t\t/** @type {ControlMode} */\n\t\tcontrolMode: 'rotate_lock',\n\t\tinvertRotationDirection: false,\n\t\tshowTimer: true,\n\t\tdisableZoomPan: false,\n\t\tassistant: false,\n\t\t/** @type {AnimationSpeed} */\n\t\tanimationSpeed: 'normal'\n\t};\n\n\tconst { subscribe, set, update } = writable(defaultSettings);\n\treturn {\n\t\tsubscribe,\n\t};\n}\n\nexport const settings = createSettings();\n\n\n\n\n\n","import { settings } from '../stores';\n\nexport function controls(node, game) {\n\tconst grid = game.grid;\n\n\tlet viewBox;\n\n\tconst unsubscribeViewBox = game.viewBox.subscribe((box) => {\n\t\tviewBox = box;\n\t});\n\tlet currentSettings;\n\tconst unsubscribeSettings = settings.subscribe((s) => {\n\t\tcurrentSettings = s;\n\t});\n\tconst useZoomPan = !currentSettings.disableZoomPan;\n\n\t/**\n\t * @type {'idle'|'mousedown'|'panning'|'locking'|'unlocking'|'edgemark'}\n\t */\n\tlet state = 'idle';\n\t/** @type PointerOrigin */\n\tlet mouseDownOrigin = {\n\t\tx: 0,\n\t\ty: 0,\n\t\tbutton: 0,\n\t\ttileIndex: 0,\n\t\ttileX: 0,\n\t\ttileY: 0,\n\t\tlocking: false\n\t};\n\n\t/**\n\t * @type {Set<Number>}\n\t */\n\tlet lockingSet = new Set();\n\n\t/**\n\t * Compute X and Y coordinates of the event in game grid units\n\t * @param {MouseEvent|Touch} event\n\t * @returns {Number[]}\n\t */\n\tfunction getEventCoordinates(event) {\n\t\tconst { x, y, width, height } = node.getBoundingClientRect();\n\t\tconst relativeX = (event.clientX - x) / width;\n\t\tconst relativeY = (event.clientY - y) / height;\n\t\tconst gameX = viewBox.xmin + relativeX * viewBox.width;\n\t\tconst gameY = viewBox.ymin + relativeY * viewBox.height;\n\t\treturn [gameX, gameY];\n\t}\n\n\tfunction save() {\n\t\tnode.dispatchEvent(new CustomEvent('save'));\n\t}\n\tlet edgeMarkTimer;\n\tfunction handleMouseDown(event) {\n\t\tevent.preventDefault();\n\t\tconst [x, y] = getEventCoordinates(event);\n\t\tconst locking = false;\n\n\t\tmouseDownOrigin = {\n\t\t\tx,\n\t\t\ty,\n\t\t\tbutton: event.button,\n\t\t\ttileIndex: -1,\n\t\t\ttileX: 0,\n\t\t\ttileY: 0,\n\t\t\tlocking\n\t\t};\n\t\tconst tile = game.grid.which_tile_at(x, y);\n\t\tif (tile.index !== -1) {\n\t\t\tmouseDownOrigin.tileIndex = tile.index;\n\t\t\tmouseDownOrigin.tileX = tile.x;\n\t\t\tmouseDownOrigin.tileY = tile.y;\n\t\t}\n\n\t\tif (mouseDownOrigin.tileIndex === -1) {\n\t\t\tif (!useZoomPan) {\n\t\t\t\tstate = 'idle';\n\t\t\t} else if (!grid.wrap && (x < grid.XMIN || x > grid.XMAX || y < grid.YMIN || y > grid.YMAX)) {\n\t\t\t\tstate = 'idle';\n\t\t\t} else {\n\t\t\t\tstate = 'panning';\n\t\t\t}\n\t\t} else {\n\t\t\tconst { direction, isClose } = game.grid.whichEdge(mouseDownOrigin);\n\t\t\tif (isClose) {\n\t\t\t\t// close to the edge, may be wanting an edge mark\n\t\t\t\tedgeMarkTimer = setTimeout(() => {\n\t\t\t\t\tconst mark = mouseDownOrigin.button === 0 ? 'wall' : 'conn';\n\t\t\t\t\tgame.toggleEdgeMark(\n\t\t\t\t\t\tmark,\n\t\t\t\t\t\tmouseDownOrigin.tileIndex,\n\t\t\t\t\t\tdirection,\n\t\t\t\t\t\tcurrentSettings.assistant\n\t\t\t\t\t);\n\t\t\t\t\tstate = 'edgemark';\n\t\t\t\t}, 300);\n\t\t\t\tstate = 'mousedown';\n\t\t\t} else {\n\t\t\t\tif (mouseDownOrigin.locking) {\n\t\t\t\t\tlockingSet.add(mouseDownOrigin.tileIndex);\n\t\t\t\t\tconst locked = false\n\t\t\t\t\tstate = locked ? 'locking' : 'unlocking';\n\t\t\t\t\tsave();\n\t\t\t\t} else {\n\t\t\t\t\tstate = 'mousedown';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction handleMouseUp(event) {\n\t\tclearTimeout(edgeMarkTimer);\n\t\tif (state === 'idle' || state === 'edgemark') {\n\t\t\treturn;\n\t\t}\n\t\tevent.preventDefault();\n\t\tconst [x, y] = getEventCoordinates(event);\n\t\tconst dx = x - mouseDownOrigin.x;\n\t\tconst dy = y - mouseDownOrigin.y;\n\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\tif (state === 'mousedown' && mouseDownOrigin.tileIndex !== -1 && distance >= 0.2) {\n\t\t\t// const tileIndex = mouseDownOrigin.tileIndex;\n\t\t\t// // this might be drawing an edge mark\n\t\t\t// const { mark, direction } = grid.detectEdgemarkGesture(\n\t\t\t// \ttileIndex,\n\t\t\t// \tmouseDownOrigin.tileX,\n\t\t\t// \tmouseDownOrigin.tileY,\n\t\t\t// \tmouseDownOrigin.x,\n\t\t\t// \tx,\n\t\t\t// \tmouseDownOrigin.y,\n\t\t\t// \ty\n\t\t\t// );\n\t\t\t// if (mark !== 'none') {\n\t\t\t// \tgame.toggleEdgeMark(mark, tileIndex, direction, currentSettings.assistant);\n\t\t\t// \tsave();\n\t\t\t// \ttouchState = 'idle';\n\t\t\t// }\n\t\t}\n\t\tif (state === 'mousedown' && mouseDownOrigin.tileIndex !== -1 && distance <= 0.2) {\n\t\t\t// process this as a click\n\t\t\t// rotate or lock a tile\n\t\t\tconst tileIndex = mouseDownOrigin.tileIndex;\n\t\t\tconst tileState = game.tileStates[tileIndex];\n\t\t\tconst leftButton = mouseDownOrigin.button === 0;\n\t\t\tconst rightButton = mouseDownOrigin.button === 2;\n\t\t\tif (currentSettings.controlMode === 'rotate_lock') {\n\t\t\t\tlet rotationTimes = currentSettings.invertRotationDirection ? -1 : 1;\n\t\t\t\tif (leftButton && !event.ctrlKey) {\n\t\t\t\t\tgame.rotateTile(tileIndex, rotationTimes);\n\t\t\t\t} else if (leftButton && event.ctrlKey) {\n\t\t\t\t\tgame.rotateTile(tileIndex, -rotationTimes);\n\t\t\t\t}\n\t\t\t} else if (currentSettings.controlMode === 'rotate_rotate') {\n\t\t\t\tlet rotationTimes = currentSettings.invertRotationDirection ? -1 : 1;\n\t\t\t\tif (leftButton && event.ctrlKey) {\n\t\t\t\t} else if (leftButton && !event.ctrlKey) {\n\t\t\t\t\tgame.rotateTile(tileIndex, rotationTimes);\n\t\t\t\t} else if (rightButton) {\n\t\t\t\t\tgame.rotateTile(tileIndex, -rotationTimes);\n\t\t\t\t}\n\t\t\t} else if (currentSettings.controlMode === 'orient_lock') {\n\t\t\t\tif (leftButton) {\n\t\t\t\t\tconst { tileX, tileY } = mouseDownOrigin;\n\t\t\t\t\tconst angle = Math.atan2(tileY - y, x - tileX);\n\t\t\t\t\tconst timesRotate = game.grid.clickOrientTile(\n\t\t\t\t\t\ttileState.data.tile,\n\t\t\t\t\t\ttileState.data.rotations,\n\t\t\t\t\t\tangle,\n\t\t\t\t\t\ttileIndex\n\t\t\t\t\t);\n\t\t\t\t\tgame.rotateTile(tileIndex, timesRotate);\n\t\t\t\t} else if (rightButton) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tsave();\n\t\t}\n\t\tlockingSet.clear();\n\t\tstate = 'idle';\n\t}\n\n\t/**@type {TouchOrigin[]} */\n\t/**@type {'idle'|'touchdown'|'zoom_pan'|'panning'|'locking'|'unlocking'} */\n\tlet touchState = 'idle';\n\tnode.addEventListener('mousedown', handleMouseDown);\n\tdocument.addEventListener('mouseup', handleMouseUp);\n\n\treturn {\n\t\tdestroy() {\n\t\t\tnode.removeEventListener('mousedown', handleMouseDown);\n\t\t\tdocument.removeEventListener('mouseup', handleMouseUp);\n\t\t\tunsubscribeViewBox();\n\t\t\tunsubscribeSettings();\n\t\t}\n\t};\n}\n","<script>\n\t/** @type {Number} i*/\n\texport let i;\n\n\t/**\n\t * @type {import('$lib/puzzle/game').PipesGame} game\n\t */\n\texport let game;\n\texport let cx = 0;\n\texport let cy = 0;\n\n\tlet state = game.tileStates[i];\n\tconst disconnectStrokeWidthScale = game.disconnectStrokeWidthScale;\n\tconst disconnectStrokeColor = game.disconnectStrokeColor;\n\n\tlet bgColor = 'purple';\n\tlet strokeColor = '#888';\n\tlet strokeWidth = game.grid.STROKE_WIDTH;\n\tlet outlineWidth = 2 * strokeWidth + game.grid.PIPE_WIDTH;\n\n\tconst myDirections = game.grid.getDirections($state.tile, 0, i);\n\n\tconst [guideX, guideY] = game.grid.getGuideDotPosition($state.tile, i);\n\n\tconst pipeWidth = game.grid.PIPE_WIDTH;\n\n\tlet path = game.grid.getPipesPath($state.tile, i);\n\tconst isSink = myDirections.length === 1;\n\n\t$: if ($state.hasDisconnects) {\n\t\tstrokeColor = '#baa660' // \n\t\tstrokeWidth = game.grid.STROKE_WIDTH * $disconnectStrokeWidthScale;\n\t} else if ($state.isPartOfIsland) {\n\t\tstrokeColor = 'red'; // \n\t\tstrokeWidth = game.grid.STROKE_WIDTH;\n\t} else {\n\t\tstrokeColor = '#d3be70'; // \n\t\tstrokeWidth = game.grid.STROKE_WIDTH;\n\t}\n\t$: outlineWidth = 2 * strokeWidth + game.grid.PIPE_WIDTH;\n</script>\n\n<g class=\"tile\" transform=\"translate({cx},{cy})\">\n\t<!-- Tile hexagon -->\n\t<path d={game.grid.getTilePath(i)} fill=\"transparent\"\n\t\t\t\tstroke-width=\"0.02\"\n\t\t\t\tstroke=\"rgba(255,255,255,.3)\"\n\t/>\n\n\t<!-- Pipe shape -->\n\t<g class=\"pipe\" style=\"transform:rotate({game.grid.getAngle($state.rotations, i)}rad)\">\n\t\t<!-- Pipe outline -->\n\t\t<path\n\t\t\td={path}\n\t\t\tstroke={strokeColor}\n\t\t\tstroke-width={outlineWidth}\n\t\t\tstroke-linejoin=\"bevel\"\n\t\t\tstroke-linecap=\"round\"\n\t\t/>\n\t\t<!-- Sink circle -->\n\t\t{#if isSink}\n\t\t\t<circle\n\t\t\t\tcx=\"0\"\n\t\t\t\tcy=\"0\"\n\t\t\t\tr={game.grid.SINK_RADIUS}\n\t\t\t\tfill={$state.color}\n\t\t\t\tstroke={strokeColor}\n\t\t\t\tstroke-width={strokeWidth}\n\t\t\t\tclass=\"inside\"\n\t\t\t/>\n\t\t{/if}\n\t\t<!-- Pipe inside -->\n\t\t<path\n\t\t\tclass=\"inside\"\n\t\t\td={path}\n\t\t\tstroke={$state.color}\n\t\t\tstroke-width={pipeWidth}\n\t\t\tstroke-linejoin=\"round\"\n\t\t\tstroke-linecap=\"round\"\n\t\t/>\n\t</g>\n</g>\n\n<style>\n\t:global(.animation-normal) .pipe {\n\t\ttransition: transform 100ms ease;\n\t}\n\t:global(.animation-fast) .pipe {\n\t\ttransition: transform 30ms ease;\n\t}\n\t:global(.animation-instant) .pipe {\n\t\ttransition: transform 0ms;\n\t}\n</style>\n","// randomColor by David Merfield under the CC0 license\n// https://github.com/davidmerfield/randomColor/\n\n;(function(root, factory) {\n\n  // Support CommonJS\n  if (typeof exports === 'object') {\n    var randomColor = factory();\n\n    // Support NodeJS & Component, which allow module.exports to be a function\n    if (typeof module === 'object' && module && module.exports) {\n      exports = module.exports = randomColor;\n    }\n\n    // Support CommonJS 1.1.1 spec\n    exports.randomColor = randomColor;\n\n  // Support AMD\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory);\n\n  // Support vanilla script loading\n  } else {\n    root.randomColor = factory();\n  }\n\n}(this, function() {\n\n  // Seed to get repeatable colors\n  var seed = null;\n\n  // Shared color dictionary\n  var colorDictionary = {};\n\n  // Populate the color dictionary\n  loadColorBounds();\n\n  // check if a range is taken\n  var colorRanges = [];\n\n  var randomColor = function (options) {\n\n    options = options || {};\n\n    // Check if there is a seed and ensure it's an\n    // integer. Otherwise, reset the seed value.\n    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {\n      seed = options.seed;\n\n    // A string was passed as a seed\n    } else if (typeof options.seed === 'string') {\n      seed = stringToInteger(options.seed);\n\n    // Something was passed as a seed but it wasn't an integer or string\n    } else if (options.seed !== undefined && options.seed !== null) {\n      throw new TypeError('The seed value must be an integer or string');\n\n    // No seed, reset the value outside.\n    } else {\n      seed = null;\n    }\n\n    var H,S,B;\n\n    // Check if we need to generate multiple colors\n    if (options.count !== null && options.count !== undefined) {\n\n      var totalColors = options.count,\n          colors = [];\n      // Value false at index i means the range i is not taken yet.\n      for (var i = 0; i < options.count; i++) {\n        colorRanges.push(false)\n        }\n      options.count = null;\n\n      while (totalColors > colors.length) {\n\n        var color = randomColor(options);\n\n        if (seed !== null) {\n          options.seed = seed;\n        }\n\n        colors.push(color);\n      }\n\n      options.count = totalColors;\n\n      return colors;\n    }\n\n    // First we pick a hue (H)\n    H = pickHue(options);\n\n    // Then use H to determine saturation (S)\n    S = pickSaturation(H, options);\n\n    // Then use S and H to determine brightness (B).\n    B = pickBrightness(H, S, options);\n\n    // Then we return the HSB color in the desired format\n    return setFormat([H,S,B], options);\n  };\n\n  function pickHue(options) {\n    if (colorRanges.length > 0) {\n      var hueRange = getRealHueRange(options.hue)\n\n      var hue = randomWithin(hueRange)\n\n      //Each of colorRanges.length ranges has a length equal approximatelly one step\n      var step = (hueRange[1] - hueRange[0]) / colorRanges.length\n\n      var j = parseInt((hue - hueRange[0]) / step)\n\n      //Check if the range j is taken\n      if (colorRanges[j] === true) {\n        j = (j + 2) % colorRanges.length\n      }\n      else {\n        colorRanges[j] = true\n           }\n\n      var min = (hueRange[0] + j * step) % 359,\n          max = (hueRange[0] + (j + 1) * step) % 359;\n\n      hueRange = [min, max]\n\n      hue = randomWithin(hueRange)\n\n      if (hue < 0) {hue = 360 + hue;}\n      return hue\n    }\n    else {\n      var hueRange = getHueRange(options.hue)\n\n      hue = randomWithin(hueRange);\n      // Instead of storing red as two seperate ranges,\n      // we group them, using negative numbers\n      if (hue < 0) {\n        hue = 360 + hue;\n      }\n\n      return hue;\n    }\n  }\n\n  function pickSaturation (hue, options) {\n\n    if (options.hue === 'monochrome') {\n      return 0;\n    }\n\n    if (options.luminosity === 'random') {\n      return randomWithin([0,100]);\n    }\n\n    var saturationRange = getSaturationRange(hue);\n\n    var sMin = saturationRange[0],\n        sMax = saturationRange[1];\n\n    switch (options.luminosity) {\n\n      case 'bright':\n        sMin = 55;\n        break;\n\n      case 'dark':\n        sMin = sMax - 10;\n        break;\n\n      case 'light':\n        sMax = 55;\n        break;\n   }\n\n    return randomWithin([sMin, sMax]);\n\n  }\n\n  function pickBrightness (H, S, options) {\n\n    var bMin = getMinimumBrightness(H, S),\n        bMax = 100;\n\n    switch (options.luminosity) {\n\n      case 'dark':\n        bMax = bMin + 20;\n        break;\n\n      case 'light':\n        bMin = (bMax + bMin)/2;\n        break;\n\n      case 'random':\n        bMin = 0;\n        bMax = 100;\n        break;\n    }\n\n    return randomWithin([bMin, bMax]);\n  }\n\n  function setFormat (hsv, options) {\n\n    switch (options.format) {\n\n      case 'hsvArray':\n        return hsv;\n\n      case 'hslArray':\n        return HSVtoHSL(hsv);\n\n      case 'hsl':\n        var hsl = HSVtoHSL(hsv);\n        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';\n\n      case 'hsla':\n        var hslColor = HSVtoHSL(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';\n\n      case 'rgbArray':\n        return HSVtoRGB(hsv);\n\n      case 'rgb':\n        var rgb = HSVtoRGB(hsv);\n        return 'rgb(' + rgb.join(', ') + ')';\n\n      case 'rgba':\n        var rgbColor = HSVtoRGB(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';\n\n      default:\n        return HSVtoHex(hsv);\n    }\n\n  }\n\n  function getMinimumBrightness(H, S) {\n\n    var lowerBounds = getColorInfo(H).lowerBounds;\n\n    for (var i = 0; i < lowerBounds.length - 1; i++) {\n\n      var s1 = lowerBounds[i][0],\n          v1 = lowerBounds[i][1];\n\n      var s2 = lowerBounds[i+1][0],\n          v2 = lowerBounds[i+1][1];\n\n      if (S >= s1 && S <= s2) {\n\n         var m = (v2 - v1)/(s2 - s1),\n             b = v1 - m*s1;\n\n         return m*S + b;\n      }\n\n    }\n\n    return 0;\n  }\n\n  function getHueRange (colorInput) {\n\n    if (typeof parseInt(colorInput) === 'number') {\n\n      var number = parseInt(colorInput);\n\n      if (number < 360 && number > 0) {\n        return [number, number];\n      }\n\n    }\n\n    if (typeof colorInput === 'string') {\n\n      if (colorDictionary[colorInput]) {\n        var color = colorDictionary[colorInput];\n        if (color.hueRange) {return color.hueRange;}\n      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorInput)[0];\n        return [ hue, hue ];\n      }\n    }\n\n    return [0,360];\n\n  }\n\n  function getSaturationRange (hue) {\n    return getColorInfo(hue).saturationRange;\n  }\n\n  function getColorInfo (hue) {\n\n    // Maps red colors to make picking hue easier\n    if (hue >= 334 && hue <= 360) {\n      hue-= 360;\n    }\n\n    for (var colorName in colorDictionary) {\n       var color = colorDictionary[colorName];\n       if (color.hueRange &&\n           hue >= color.hueRange[0] &&\n           hue <= color.hueRange[1]) {\n          return colorDictionary[colorName];\n       }\n    } return 'Color not found';\n  }\n\n  function randomWithin (range) {\n    if (seed === null) {\n      //generate random evenly destinct number from : https://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/\n      var golden_ratio = 0.618033988749895\n      var r=Math.random()\n      r += golden_ratio\n      r %= 1\n      return Math.floor(range[0] + r*(range[1] + 1 - range[0]));\n    } else {\n      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n      var max = range[1] || 1;\n      var min = range[0] || 0;\n      seed = (seed * 9301 + 49297) % 233280;\n      var rnd = seed / 233280.0;\n      return Math.floor(min + rnd * (max - min));\n}\n  }\n\n  function HSVtoHex (hsv){\n\n    var rgb = HSVtoRGB(hsv);\n\n    function componentToHex(c) {\n        var hex = c.toString(16);\n        return hex.length == 1 ? '0' + hex : hex;\n    }\n\n    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);\n\n    return hex;\n\n  }\n\n  function defineColor (name, hueRange, lowerBounds) {\n\n    var sMin = lowerBounds[0][0],\n        sMax = lowerBounds[lowerBounds.length - 1][0],\n\n        bMin = lowerBounds[lowerBounds.length - 1][1],\n        bMax = lowerBounds[0][1];\n\n    colorDictionary[name] = {\n      hueRange: hueRange,\n      lowerBounds: lowerBounds,\n      saturationRange: [sMin, sMax],\n      brightnessRange: [bMin, bMax]\n    };\n\n  }\n\n  function loadColorBounds () {\n\n    defineColor(\n      'monochrome',\n      null,\n      [[0,0],[100,0]]\n    );\n\n    defineColor(\n      'red',\n      [-26,18],\n      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]\n    );\n\n    defineColor(\n      'orange',\n      [18,46],\n      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]\n    );\n\n    defineColor(\n      'yellow',\n      [46,62],\n      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]\n    );\n\n    defineColor(\n      'green',\n      [62,178],\n      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]\n    );\n\n    defineColor(\n      'blue',\n      [178, 257],\n      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]\n    );\n\n    defineColor(\n      'purple',\n      [257, 282],\n      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]\n    );\n\n    defineColor(\n      'pink',\n      [282, 334],\n      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]\n    );\n\n  }\n\n  function HSVtoRGB (hsv) {\n\n    // this doesn't work for the values of 0 and 360\n    // here's the hacky fix\n    var h = hsv[0];\n    if (h === 0) {h = 1;}\n    if (h === 360) {h = 359;}\n\n    // Rebase the h,s,v values\n    h = h/360;\n    var s = hsv[1]/100,\n        v = hsv[2]/100;\n\n    var h_i = Math.floor(h*6),\n      f = h * 6 - h_i,\n      p = v * (1 - s),\n      q = v * (1 - f*s),\n      t = v * (1 - (1 - f)*s),\n      r = 256,\n      g = 256,\n      b = 256;\n\n    switch(h_i) {\n      case 0: r = v; g = t; b = p;  break;\n      case 1: r = q; g = v; b = p;  break;\n      case 2: r = p; g = v; b = t;  break;\n      case 3: r = p; g = q; b = v;  break;\n      case 4: r = t; g = p; b = v;  break;\n      case 5: r = v; g = p; b = q;  break;\n    }\n\n    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];\n    return result;\n  }\n\n  function HexToHSB (hex) {\n    hex = hex.replace(/^#/, '');\n    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;\n\n    var red = parseInt(hex.substr(0, 2), 16) / 255,\n          green = parseInt(hex.substr(2, 2), 16) / 255,\n          blue = parseInt(hex.substr(4, 2), 16) / 255;\n\n    var cMax = Math.max(red, green, blue),\n          delta = cMax - Math.min(red, green, blue),\n          saturation = cMax ? (delta / cMax) : 0;\n\n    switch (cMax) {\n      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];\n      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];\n      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];\n    }\n  }\n\n  function HSVtoHSL (hsv) {\n    var h = hsv[0],\n      s = hsv[1]/100,\n      v = hsv[2]/100,\n      k = (2-s)*v;\n\n    return [\n      h,\n      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,\n      k/2 * 100\n    ];\n  }\n\n  function stringToInteger (string) {\n    var total = 0\n    for (var i = 0; i !== string.length; i++) {\n      if (total >= Number.MAX_SAFE_INTEGER) break;\n      total += string.charCodeAt(i)\n    }\n    return total\n  }\n\n  // get The range of given hue when options.count!=0\n  function getRealHueRange(colorHue)\n  { if (!isNaN(colorHue)) {\n    var number = parseInt(colorHue);\n\n    if (number < 360 && number > 0) {\n      return getColorInfo(colorHue).hueRange\n    }\n  }\n    else if (typeof colorHue === 'string') {\n\n      if (colorDictionary[colorHue]) {\n        var color = colorDictionary[colorHue];\n\n        if (color.hueRange) {\n          return color.hueRange\n       }\n    } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorHue)[0]\n        return getColorInfo(hue).hueRange\n    }\n  }\n\n    return [0,360]\n}\n  return randomColor;\n}));\n","import { writable } from 'svelte/store';\n\nexport function createViewBox(grid) {\n\tconst initial = {\n\t\txmin: grid.XMIN,\n\t\tymin: grid.YMIN,\n\t\twidth: grid.XMAX - grid.XMIN,\n\t\theight: grid.YMAX - grid.YMIN\n\t};\n\n\tconst { subscribe, set, update } = writable(initial);\n\n\tfunction fixBoxBounds(box) {\n\t\tif (grid.wrap) {\n\t\t\treturn box;\n\t\t}\n\t\tlet xmin = box.xmin;\n\t\tlet ymin = box.ymin;\n\t\tlet width = box.width;\n\t\tlet height = box.height;\n\t\tconst dw = box.width - (grid.XMAX - grid.XMIN);\n\t\tconst dh = box.height - (grid.YMAX - grid.YMIN);\n\t\tif (dw > 0 && dh > 0) {\n\t\t\t// zoomed too far out, bring them back\n\t\t\tif (dw <= dh) {\n\t\t\t\twidth = box.width - dw;\n\t\t\t\theight = box.height - (dw * box.height) / box.width;\n\t\t\t} else {\n\t\t\t\theight = box.height - dh;\n\t\t\t\twidth = box.width - (dh * box.width) / box.height;\n\t\t\t}\n\t\t\txmin = 0.5 * (grid.XMIN + grid.XMAX) - width / 2;\n\t\t\tymin = 0.5 * (grid.YMIN + grid.YMAX) - height / 2;\n\t\t} else {\n\t\t\tif (dw < 0) {\n\t\t\t\t// zoomed in horizontally, don't allow bounds to leave [XMIN, XMAX]\n\t\t\t\txmin = Math.max(grid.XMIN, xmin);\n\t\t\t\txmin = Math.min(xmin, grid.XMAX - width);\n\t\t\t}\n\t\t\tif (dh < 0) {\n\t\t\t\t// zoomed in vertically, don't allow bounds to leave [YMIN, YMAX]\n\t\t\t\tymin = Math.max(grid.YMIN, ymin);\n\t\t\t\tymin = Math.min(ymin, grid.YMAX - height);\n\t\t\t}\n\t\t}\n\t\treturn { xmin, ymin, width, height };\n\t}\n\n\t/** @type {NodeJS.Timer|null} */\n\tlet visibleTilesTimeoutId = null;\n\t/** @type {ViewBox} */\n\tlet lastBox;\n\n\tconst visibleTiles = writable([]);\n\n\tsubscribe((box) => {\n\t\tlastBox = box;\n\t\tif (visibleTilesTimeoutId === null) {\n\t\t\tvisibleTilesTimeoutId = setTimeout(() => {\n\t\t\t\tvisibleTilesTimeoutId = null;\n\t\t\t\tconst visible = grid.getVisibleTiles(lastBox);\n\t\t\t\tvisibleTiles.set(visible);\n\t\t\t}, 100);\n\t\t}\n\t});\n\n\n\t/**\n\t * Move viewbox around\n\t * @param {Number} dx\n\t * @param {Number} dy\n\t */\n\tfunction pan(dx, dy) {\n\t\tupdate((box) => {\n\t\t\treturn fixBoxBounds({\n\t\t\t\txmin: box.xmin - dx,\n\t\t\t\tymin: box.ymin - dy,\n\t\t\t\twidth: box.width,\n\t\t\t\theight: box.height\n\t\t\t});\n\t\t});\n\t}\n\n\treturn {\n\t\tsubscribe,\n\t\tset,\n\t\tpan,\n\t\tvisibleTiles: { subscribe: visibleTiles.subscribe }\n\t};\n}\n","import randomColor from 'randomcolor';\nimport { writable } from 'svelte/store';\nimport { createViewBox } from './viewbox';\n\nfunction StateStore(initialState) {\n\tlet self = this;\n\n\tconst { subscribe, set, update } = writable(initialState);\n\tself.data = Object.assign({}, initialState);\n\tself.subscribe = subscribe;\n\n\t/**\n\t * @param {TileState} newValue\n\t */\n\tself.set = function (newValue) {\n\t\tself.data = newValue;\n\t\tset(newValue);\n\t};\n\n\t/**\n\t * @param {String} color\n\t */\n\tself.setColor = function (color) {\n\t\tself.data.color = color;\n\t\tset(self.data);\n\t};\n\n\tself.toggleLocked = function () {\n\t\tself.data.locked = !self.data.locked;\n\t\tset(self.data);\n\t};\n\n\t/**\n\t * @param {Boolean} isPartOfLoop\n\t */\n\tself.setPartOfLoop = function (isPartOfLoop) {\n\t\tself.data.isPartOfLoop = isPartOfLoop;\n\t\tset(self.data);\n\t};\n\t/**\n\t * @param {Boolean} isPartOfIsland\n\t */\n\tself.setPartOfIsland = function (isPartOfIsland) {\n\t\tself.data.isPartOfIsland = isPartOfIsland;\n\t\tset(self.data);\n\t};\n\t/**\n\t * @param {Boolean} hasDisconnects\n\t */\n\tself.setHasDisconnects = function (hasDisconnects) {\n\t\tself.data.hasDisconnects = hasDisconnects;\n\t\tset(self.data);\n\t};\n\n\t/**\n\t * @param {Number} times\n\t */\n\tself.rotate = function (times) {\n\t\tself.data.rotations += times;\n\t\tset(self.data);\n\t};\n\n\treturn self;\n}\n\nexport function PipesGame(grid, tiles, savedProgress) {\n\tlet self = this;\n\tself.grid = grid;\n\tself.tiles = tiles;\n\tself.initialized = false;\n\tself._solved = false;\n\tself.solved = writable(false);\n\tself.viewBox = createViewBox(grid);\n\n\tself.connections = new Map();\n\tself.tileStates = [];\n\tself.components = new Map();\n\tself.openEnds = new Set();\n\tconst totalTiles = grid.total - grid.emptyCells.size;\n\tself.shareDisconnectedTiles = writable(1);\n\tself.disconnectStrokeWidthScale = writable(1);\n\tself.disconnectStrokeColor = writable('#888888');\n\n\tself.shareDisconnectedTiles.subscribe((value) => {\n\t\tif (value > 0.1) {\n\t\t\treturn;\n\t\t}\n\t\tconst amount = 1 - value * 10;\n\t\tconst color = Math.round(136 - 34 * amount).toString(16);\n\t\tself.disconnectStrokeColor.set('#' + color + color + color);\n\t\tself.disconnectStrokeWidthScale.set(1 + 0.4 * amount);\n\t});\n\n\tconst defaultEdgeMarks = ['empty', 'empty', 'empty'];\n\tself.tileStates = tiles.map((tile, index) => {\n\t\t// disable edge marks on outer edges of non-wrap puzzles\n\t\tconst edgeMarks = [...defaultEdgeMarks];\n\t\tif (!self.grid.wrap) {\n\t\t\tself.grid.EDGEMARK_DIRECTIONS.forEach((direction, direction_index) => {\n\t\t\t\tconst { empty } = self.grid.find_neighbour(index, direction);\n\t\t\t\tif (empty) {\n\t\t\t\t\tedgeMarks[direction_index] = 'none';\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn new StateStore({\n\t\t\ttile: tile,\n\t\t\trotations: 0,\n\t\t\tcolor: 'white',\n\t\t\tisPartOfLoop: false,\n\t\t\tisPartOfIsland: false,\n\t\t\thasDisconnects: false,\n\t\t\tlocked: false,\n\t\t\tedgeMarks\n\t\t});\n\t});\n\n\tself.initializeBoard = function () {\n\t\t// create components and fill in connections data\n\t\tself.tileStates.forEach((tileState, index) => {\n\t\t\tconst state = tileState.data;\n\t\t\tlet directions = self.grid.getDirections(state.tile, state.rotations, index);\n\t\t\tconst connections = new Set();\n\t\t\tfor (let direction of directions) {\n\t\t\t\tconst { neighbour, empty } = grid.find_neighbour(index, direction);\n\t\t\t\tif (!empty) {\n\t\t\t\t\tconnections.add(neighbour);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (connections.size < directions.length) {\n\t\t\t\t// some connections point outside the grid\n\t\t\t\ttileState.setHasDisconnects(true);\n\t\t\t}\n\t\t\tself.connections.set(index, connections);\n\t\t});\n\t\t// merge initial components of connected tiles\n\t\tconst checked = new Set();\n\t\tlet i = 0;\n\t\tconst empty = new Set();\n\t\twhile (checked.size < self.tileStates.length) {\n\t\t\tconst toCheck = new Set([i]);\n\t\t\tconst state = self.tileStates[i].data;\n\t\t\tconst component = {\n\t\t\t\tcolor: state.color,\n\t\t\t\ttiles: new Set([i]),\n\t\t\t\topenEnds: new Set()\n\t\t\t};\n\t\t\tconst connectedThrough = new Map();\n\t\t\tlet loop = false;\n\t\t\twhile (toCheck.size > 0) {\n\t\t\t\tconst index = toCheck.values().next().value;\n\t\t\t\tconst tileState = self.tileStates[index];\n\t\t\t\ttoCheck.delete(index);\n\t\t\t\tchecked.add(index);\n\t\t\t\tself.components.set(index, component);\n\t\t\t\tcomponent.tiles.add(index);\n\t\t\t\tif (tileState.data.hasDisconnects) {\n\t\t\t\t\tcomponent.openEnds.add(index);\n\t\t\t\t\tself.openEnds.add(index);\n\t\t\t\t}\n\t\t\t\tconst connected = self.connections.get(index) || empty;\n\t\t\t\tfor (let neighbour of connected) {\n\t\t\t\t\tconst through = connectedThrough.get(neighbour) || -1;\n\t\t\t\t\tif (through === index) {\n\t\t\t\t\t\t// seen this connection before\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif ((self.connections.get(neighbour) || empty).has(index)) {\n\t\t\t\t\t\tif (through !== -1) {\n\t\t\t\t\t\t\t// connected to the same component through some other tile\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttoCheck.add(neighbour);\n\t\t\t\t\t\tconnectedThrough.set(neighbour, index);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttileState.setHasDisconnects(true);\n\t\t\t\t\t\tcomponent.openEnds.add(index);\n\t\t\t\t\t\tself.openEnds.add(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (loop) {\n\t\t\t\tconst loopTiles = self.detectLoops(component.tiles);\n\t\t\t\tfor (let loopTile of loopTiles) {\n\t\t\t\t\tself.tileStates[loopTile].setPartOfLoop(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (component.openEnds.size === 0) {\n\t\t\t\tfor (let islandTile of component.tiles) {\n\t\t\t\t\tself.tileStates[islandTile].setPartOfIsland(true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (checked.has(i)) {\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t}\n\t\tself.shareDisconnectedTiles.set(self.openEnds.size / totalTiles);\n\t\tself.initialized = true;\n\t};\n\n\tself.rotateTile = function (tileIndex, times) {\n\t\tif (self._solved || times === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst tileState = self.tileStates[tileIndex];\n\t\tif (tileState === undefined || tileState.data.locked) {\n\t\t\treturn;\n\t\t}\n\t\tconst oldDirections = self.grid.getDirections(\n\t\t\ttileState.data.tile,\n\t\t\ttileState.data.rotations,\n\t\t\ttileIndex\n\t\t);\n\t\ttileState.rotate(times);\n\t\tconst newDirections = self.grid.getDirections(\n\t\t\ttileState.data.tile,\n\t\t\ttileState.data.rotations,\n\t\t\ttileIndex\n\t\t);\n\n\t\tconst dirOut = oldDirections.filter((direction) => !newDirections.some((d) => d === direction));\n\t\tconst dirIn = newDirections.filter((direction) => !oldDirections.some((d) => d === direction));\n\n\t\tself.handleConnections({\n\t\t\tdetail: { tileIndex, dirOut, dirIn }\n\t\t});\n\t};\n\n\tself.setTileOrientation = function (tileIndex, orientation, animate = false) {\n\t\tconst tileState = self.tileStates[tileIndex];\n\t\tif (tileState === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tconst initial = self.tiles[tileIndex];\n\t\tlet newState = initial;\n\t\tlet rotations = 0;\n\t\twhile (newState !== orientation && rotations < self.grid.DIRECTIONS.length) {\n\t\t\tnewState = self.grid.rotate(newState, 1, tileIndex);\n\t\t\trotations += 1;\n\t\t}\n\t\tif (rotations === self.grid.DIRECTIONS.length) {\n\t\t\tthrow `No way to rotate tile at ${tileIndex} from ${initial} to ${orientation}`;\n\t\t}\n\t\tconst current = tileState.data.rotations;\n\t\tconst delta = (rotations - current) % self.grid.DIRECTIONS.length;\n\t\tif (delta !== 0 || animate) {\n\t\t\tself.rotateTile(tileIndex, delta || self.grid.DIRECTIONS.length);\n\t\t}\n\t};\n\n\tself.toggleEdgeMark = function (mark, tileIndex, direction, assistant = false) {\n\t\tconst { neighbour, empty } = self.grid.find_neighbour(tileIndex, direction);\n\t\tconst index = self.grid.EDGEMARK_DIRECTIONS.indexOf(direction);\n\t\tif (index === -1) {\n\t\t\t// toggle mark on the neighbour instead\n\t\t\tconst opposite = self.grid.OPPOSITE.get(direction);\n\t\t\tif (!empty && opposite) {\n\t\t\t\tself.toggleEdgeMark(mark, neighbour, opposite, assistant);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst tileState = self.tileStates[tileIndex];\n\t\tif (tileState.data.edgeMarks[index] === mark) {\n\t\t\ttileState.data.edgeMarks[index] = 'empty';\n\t\t} else if (tileState.data.edgeMarks[index] !== 'none') {\n\t\t\ttileState.data.edgeMarks[index] = mark;\n\t\t}\n\t\ttileState.set(tileState.data);\n\t\tif (tileState.data.edgeMarks[index] !== 'empty' && assistant) {\n\t\t\tself.rotateToMatchMarks(tileIndex);\n\t\t\tself.rotateToMatchMarks(neighbour);\n\t\t}\n\t};\n\n\tself.rotateToMatchMarks = function (tileIndex) {\n\t\tconst tileState = self.tileStates[tileIndex];\n\t\tif (tileState.data.locked) {\n\t\t\treturn;\n\t\t}\n\t\tlet walls = 0;\n\t\tlet connections = 0;\n\t\tfor (let direction of self.grid.DIRECTIONS) {\n\t\t\tconst { neighbour, empty } = self.grid.find_neighbour(tileIndex, direction);\n\t\t\tif (empty) {\n\t\t\t\twalls += direction;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (self.tileStates[neighbour].data.locked) {\n\t\t\t\tif (self.connections.get(neighbour)?.has(tileIndex)) {\n\t\t\t\t\tconnections += direction;\n\t\t\t\t} else {\n\t\t\t\t\twalls += direction;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst index = self.grid.EDGEMARK_DIRECTIONS.indexOf(direction);\n\t\t\t/** @type {EdgeMark} */\n\t\t\tlet mark = 'empty';\n\t\t\tif (index === -1) {\n\t\t\t\t// neighbour state has info about this mark\n\t\t\t\tconst opposite = self.grid.OPPOSITE.get(direction) || 0;\n\t\t\t\tconst oppositeIndex = self.grid.EDGEMARK_DIRECTIONS.indexOf(opposite);\n\t\t\t\tmark = self.tileStates[neighbour].data.edgeMarks[oppositeIndex];\n\t\t\t} else {\n\t\t\t\tmark = tileState.data.edgeMarks[index];\n\t\t\t}\n\t\t\tif (mark === 'conn') {\n\t\t\t\tconnections += direction;\n\t\t\t} else if (mark === 'wall') {\n\t\t\t\twalls += direction;\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.DIRECTIONS.length; r++) {\n\t\t\tconst rotations = tileState.data.rotations + r;\n\t\t\tconst rotated = self.grid.rotate(tileState.data.tile, rotations, tileIndex);\n\t\t\tif ((rotated & connections) === connections && (rotated & walls) === 0) {\n\t\t\t\tself.rotateTile(tileIndex, r);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tself.handleConnections = function (event) {\n\t\tconst { tileIndex, dirIn, dirOut } = event.detail;\n\t\t// console.log('==========================');\n\t\t// console.log(tileIndex, dirIn, dirOut);\n\t\tconst tileConnections = self.connections.get(tileIndex);\n\t\tif (tileConnections === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tdirOut.forEach((direction) => {\n\t\t\tconst { neighbour, empty } = self.grid.find_neighbour(tileIndex, direction);\n\t\t\tif (empty) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttileConnections.delete(neighbour);\n\t\t\tconst neighbourConnections = self.connections.get(neighbour);\n\t\t\tif (neighbourConnections === undefined) {\n\t\t\t\tthrow `Could not find connections data for tile ${neighbour}`;\n\t\t\t}\n\t\t\tif (!neighbourConnections.has(tileIndex)) {\n\t\t\t\treturn; // this connection wasn't mutual, no action needed\n\t\t\t}\n\t\t\tconst neighbourComponent = self.components.get(neighbour);\n\t\t\tconst tileComponent = self.components.get(tileIndex);\n\t\t\tif (tileComponent === neighbourComponent) {\n\t\t\t\t// console.log('disconnecting components between tiles', tileIndex, neighbour)\n\t\t\t\tself.disconnectComponents(tileIndex, neighbour);\n\t\t\t}\n\t\t\tself.setTileDisconnects(neighbour, true);\n\t\t\tself.setTileDisconnects(tileIndex, true);\n\t\t});\n\t\tlet hasDisconnects = false;\n\t\tdirIn.forEach((direction) => {\n\t\t\tconst { neighbour, empty } = grid.find_neighbour(tileIndex, direction);\n\t\t\tif (empty) {\n\t\t\t\thasDisconnects = true;\n\t\t\t\tself.setTileDisconnects(tileIndex, true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttileConnections.add(neighbour);\n\t\t\tconst neighbourConnections = self.connections.get(neighbour);\n\t\t\tif (neighbourConnections === undefined) {\n\t\t\t\tthrow `Could not find connections data for tile ${neighbour}`;\n\t\t\t}\n\t\t\tif (!neighbourConnections.has(tileIndex)) {\n\t\t\t\thasDisconnects = true;\n\t\t\t\treturn; // non-mutual link shouldn't lead to merging\n\t\t\t}\n\t\t\t// console.log('merging components of tiles', tileIndex, neighbour)\n\t\t\tself.mergeComponents(tileIndex, neighbour);\n\t\t\tself.setTileDisconnects(neighbour);\n\t\t});\n\t\tif (hasDisconnects) {\n\t\t\tself.setTileDisconnects(tileIndex, true);\n\t\t} else {\n\t\t\tself.setTileDisconnects(tileIndex);\n\t\t}\n\t\tif (self.initialized) {\n\t\t\tself._solved = self.isSolved();\n\t\t\tif (self._solved) {\n\t\t\t\tself.solved.set(self._solved);\n\t\t\t}\n\t\t}\n\t};\n\n\tself.setTileDisconnects = function (tileIndex, hasDisconnects = undefined) {\n\t\tlet newHasDisconnects = hasDisconnects || false;\n\t\tif (hasDisconnects === undefined) {\n\t\t\tconst directions = self.grid.getDirections(\n\t\t\t\tself.tileStates[tileIndex].data.tile,\n\t\t\t\t0,\n\t\t\t\ttileIndex\n\t\t\t);\n\t\t\tconst connections = self.connections.get(tileIndex);\n\t\t\tif (directions.length > connections.size) {\n\t\t\t\tnewHasDisconnects = true;\n\t\t\t} else {\n\t\t\t\tfor (let neighbour of connections || []) {\n\t\t\t\t\tif (!self.connections.get(neighbour)?.has(tileIndex)) {\n\t\t\t\t\t\tnewHasDisconnects = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tself.tileStates[tileIndex].setHasDisconnects(newHasDisconnects);\n\t\tconst component = self.components.get(tileIndex);\n\t\tif (component === undefined) {\n\t\t\tthrow `Component open ends data for tile ${tileIndex} not found`;\n\t\t}\n\t\tif (newHasDisconnects) {\n\t\t\tif (component.openEnds.size === 0) {\n\t\t\t\tfor (let index of component.tiles) {\n\t\t\t\t\tself.tileStates[index].setPartOfIsland(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcomponent.openEnds.add(tileIndex);\n\t\t\tself.openEnds.add(tileIndex);\n\t\t} else {\n\t\t\tcomponent.openEnds.delete(tileIndex);\n\t\t\tself.openEnds.delete(tileIndex);\n\t\t\tif (component.openEnds.size === 0 && component.tiles.size < totalTiles) {\n\t\t\t\tfor (let index of component.tiles) {\n\t\t\t\t\tself.tileStates[index].setPartOfIsland(true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tself.shareDisconnectedTiles.set(self.openEnds.size / totalTiles);\n\t};\n\n\tlet firstValidIndex = 0;\n\twhile (self.grid.emptyCells.has(firstValidIndex)) {\n\t\tfirstValidIndex += 1;\n\t}\n\n\tself.isSolved = function () {\n\t\t// console.log('=================== Solved check ======================')\n\t\tconst total = self.grid.total - self.grid.emptyCells.size;\n\t\tconst component = self.components.get(firstValidIndex);\n\t\tif (component === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tif (component.tiles.size < total) {\n\t\t\t// console.log('not everything connected yet')\n\t\t\t// not everything connected yet\n\t\t\treturn false;\n\t\t}\n\t\tlet startCheckAtIndex = firstValidIndex;\n\t\tlet toCheck = new Set([{ fromIndex: -1, tileIndex: startCheckAtIndex }]);\n\t\t// console.log('start at', startCheckAtIndex)\n\t\t/** @type Set<Number> */\n\t\tconst checked = new Set([]);\n\t\twhile (toCheck.size > 0) {\n\t\t\t// console.log('toCheck = ', toCheck)\n\t\t\t/** @type {Set<{fromIndex: Number, tileIndex: Number}>} */\n\t\t\tconst newChecks = new Set([]);\n\t\t\tfor (let { fromIndex, tileIndex } of toCheck) {\n\t\t\t\t// console.log('checking tile', tileIndex, 'coming from', fromIndex)\n\t\t\t\tconst neighbours = self.connections.get(tileIndex);\n\t\t\t\tif (neighbours === undefined) {\n\t\t\t\t\tthrow `Could not find connections data for tile ${tileIndex}`;\n\t\t\t\t}\n\t\t\t\t// console.log('tile neighbours', neighbours)\n\t\t\t\tfor (let neighbour of neighbours) {\n\t\t\t\t\t// console.log('checking neighbour', neighbour)\n\t\t\t\t\tif (neighbour === -1) {\n\t\t\t\t\t\t// not solved if any tiles point outside\n\t\t\t\t\t\t// console.log('not solved for outside connection in tile', tileIndex)\n\t\t\t\t\t\tstartCheckAtIndex = tileIndex;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tconst neighbourConnections = self.connections.get(neighbour);\n\t\t\t\t\tif (neighbourConnections === undefined) {\n\t\t\t\t\t\tthrow `Could not find connections data for tile ${neighbour}`;\n\t\t\t\t\t}\n\t\t\t\t\t// console.log('neighbour connections', neighbourConnections)\n\t\t\t\t\tif (!neighbourConnections.has(tileIndex)) {\n\t\t\t\t\t\t// not solved if a connection is not mutual\n\t\t\t\t\t\t// console.log('not solved for non-mutual connection between tiles', tileIndex, neighbour)\n\t\t\t\t\t\tstartCheckAtIndex = tileIndex;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tif (neighbour !== fromIndex) {\n\t\t\t\t\t\tif (checked.has(neighbour)) {\n\t\t\t\t\t\t\t// it's a loop\n\t\t\t\t\t\t\t// console.log('not solved because of loop detected at tile', tileIndex)\n\t\t\t\t\t\t\tstartCheckAtIndex = tileIndex;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewChecks.add({ fromIndex: tileIndex, tileIndex: neighbour });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchecked.add(tileIndex);\n\t\t\t\ttoCheck = newChecks;\n\t\t\t}\n\t\t}\n\t\tif (checked.size < total) {\n\t\t\t// console.log('not solved because only', checked.size, 'of', total, 'were reached')\n\t\t\t// it's an island\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t};\n\n\tself.mergeComponents = function (fromIndex, toIndex) {\n\t\tconst fromComponent = self.components.get(fromIndex);\n\t\tconst toComponent = self.components.get(toIndex);\n\t\t// makes jsdoc stop complaining about\n\t\t// \"object is possibly undefined\"\n\t\tif (fromComponent === undefined || toComponent === undefined) {\n\t\t\t// console.log('could not find component for tile')\n\t\t\treturn;\n\t\t}\n\t\tif (fromComponent === toComponent) {\n\t\t\t// console.log('merge component to itself, its a loop', fromIndex, toIndex)\n\t\t\tconst loopTiles = self.detectLoops(fromComponent.tiles);\n\t\t\tfor (let tile of fromComponent.tiles) {\n\t\t\t\tself.tileStates[tile].setPartOfLoop(loopTiles.has(tile));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst fromIsBigger = fromComponent.tiles.size >= toComponent.tiles.size;\n\t\tconst constantComponent = fromIsBigger ? fromComponent : toComponent;\n\t\tconst changedComponent = fromIsBigger ? toComponent : fromComponent;\n\t\tif (self.initialized) {\n\t\t\tlet newColor = constantComponent.color;\n\t\t\tif (newColor === 'white') {\n\t\t\t\tnewColor = changedComponent.color;\n\t\t\t}\n\t\t\tif (newColor === 'white') {\n\t\t\t\tnewColor = randomColor({ luminosity: 'light' });\n\t\t\t}\n\t\t\tif (constantComponent.color !== newColor) {\n\t\t\t\tconstantComponent.tiles.forEach((tileIndex) => {\n\t\t\t\t\tself.tileStates[tileIndex].setColor(newColor);\n\t\t\t\t});\n\t\t\t}\n\t\t\tconstantComponent.color = newColor;\n\t\t}\n\t\tfor (let changedTile of changedComponent.tiles) {\n\t\t\tself.components.set(changedTile, constantComponent);\n\t\t\tconstantComponent.tiles.add(changedTile);\n\t\t\tself.tileStates[changedTile].setColor(constantComponent.color);\n\t\t}\n\t\tfor (let changedTile of changedComponent.openEnds) {\n\t\t\tconstantComponent.openEnds.add(changedTile);\n\t\t}\n\t};\n\n\tself.toggleLocked = function () {\n\t\treturn false;\n\t};\n\n\tself.disconnectComponents = function (fromIndex, toIndex) {\n\t\tconst bigComponent = self.components.get(fromIndex);\n\t\tif (bigComponent === undefined) {\n\t\t\treturn;\n\t\t} // this shouldn't really happen, jsdoc\n\t\tconst fromTiles = self.findConnectedTiles(toIndex, fromIndex);\n\t\tconst toTiles = self.findConnectedTiles(fromIndex, toIndex);\n\t\tif ([...fromTiles].some((tile) => toTiles.has(tile))) {\n\t\t\t// it was a loop or maybe it still is\n\t\t\t// console.log('not disconnecting because of other connection', fromIndex, toIndex)\n\t\t\tconst loopTiles = self.detectLoops(bigComponent.tiles);\n\t\t\tfor (let tile of bigComponent.tiles) {\n\t\t\t\tself.tileStates[tile].setPartOfLoop(loopTiles.has(tile));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tconst fromIsBigger = fromTiles.size >= toTiles.size;\n\t\t// const leaveTiles = fromIsBigger ? fromTiles : toTiles\n\t\tconst changeTiles = fromIsBigger ? toTiles : fromTiles;\n\t\tconst newComponent = {\n\t\t\tcolor: randomColor({ luminosity: 'light' }),\n\t\t\ttiles: changeTiles,\n\t\t\t/** @type {Set<Number>}*/\n\t\t\topenEnds: new Set([])\n\t\t};\n\n\t\tfor (let tileIndex of changeTiles) {\n\t\t\tself.components.set(tileIndex, newComponent);\n\t\t\tbigComponent.tiles.delete(tileIndex);\n\t\t\tif (bigComponent.openEnds.delete(tileIndex)) {\n\t\t\t\tnewComponent.openEnds.add(tileIndex);\n\t\t\t}\n\t\t\tself.tileStates[tileIndex].setColor(newComponent.color);\n\t\t}\n\t\t// console.log('created new component', newComponent.id, 'with tiles', [...changeTiles])\n\t};\n\n\tself.detectLoops = function (tilesSet) {\n\t\t// console.log('detect loops in set', tilesSet)\n\t\t/**\n\t\t * @type {Map<Number, Set<Number>>}\n\t\t */\n\t\tconst myConnections = new Map();\n\t\tlet toPrune = new Set();\n\t\tfor (let tile of tilesSet) {\n\t\t\tconst tileConnections = self.connections.get(tile);\n\t\t\tif (tileConnections === undefined) {\n\t\t\t\tthrow `Could not find connections data for tile ${tile}`;\n\t\t\t}\n\t\t\tconst inComponent = new Set(\n\t\t\t\t[...tileConnections].filter((x) => {\n\t\t\t\t\t// return true for mutual connections that are\n\t\t\t\t\t// part of this component\n\t\t\t\t\tif (!tilesSet.has(x)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tconst conn = self.connections.get(x);\n\t\t\t\t\tif (conn === undefined) {\n\t\t\t\t\t\tthrow `Could not find connections data for tile ${x}`;\n\t\t\t\t\t}\n\t\t\t\t\treturn conn.has(tile);\n\t\t\t\t})\n\t\t\t);\n\t\t\tmyConnections.set(tile, inComponent);\n\t\t\tif (inComponent.size === 1) {\n\t\t\t\ttoPrune.add(tile);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Prune deadend tile to exclude it from loop highlighting\n\t\t * @param {Number} tile\n\t\t * @returns {Set<Number>}\n\t\t */\n\t\tfunction pruneTile(tile) {\n\t\t\tconst neighbours = myConnections.get(tile);\n\t\t\tif (neighbours === undefined) {\n\t\t\t\tthrow `Could not find connections data for tile ${tile}`;\n\t\t\t}\n\t\t\tif (neighbours.size <= 1) {\n\t\t\t\tmyConnections.delete(tile);\n\t\t\t\tneighbours.forEach((neighbour) => {\n\t\t\t\t\tconst neighbourConn = myConnections.get(neighbour);\n\t\t\t\t\tif (neighbourConn === undefined) {\n\t\t\t\t\t\tthrow `Could not find connections data for tile ${neighbour}`;\n\t\t\t\t\t}\n\t\t\t\t\tneighbourConn.delete(tile);\n\t\t\t\t});\n\t\t\t\treturn neighbours;\n\t\t\t}\n\t\t\treturn new Set();\n\t\t}\n\n\t\tfunction pruneDeadEnds() {\n\t\t\twhile (toPrune.size > 0) {\n\t\t\t\tconst tile = toPrune.values().next().value;\n\t\t\t\ttoPrune.delete(tile);\n\t\t\t\tconst changedNeighbours = pruneTile(tile);\n\t\t\t\tchangedNeighbours.forEach((n) => toPrune.add(n));\n\t\t\t}\n\t\t}\n\n\t\tpruneDeadEnds();\n\n\t\t// at this point we have all the loops but maybe also\n\t\t// some bridges between loops\n\t\t// need to prune them too\n\t\tconst inLoops = new Set();\n\n\t\t/**\n\t\t * Tries to find a path from one tile through another\n\t\t * and back to itself\n\t\t * @param {Number} fromTile\n\t\t * @param {Number} throughTile\n\t\t * @returns {Number[]} - tile indices that make a looping path.\n\t\t * Empty array if there is no such path.\n\t\t */\n\t\tfunction traceLoopPath(fromTile, throughTile) {\n\t\t\tlet paths = [[fromTile, throughTile]];\n\t\t\twhile (paths.length > 0) {\n\t\t\t\tconst path = paths.pop();\n\t\t\t\tif (path === undefined || path.length === 0) {\n\t\t\t\t\tthrow 'Wrong path encountered while tracing loops';\n\t\t\t\t}\n\t\t\t\tconst lastTile = path[path.length - 1];\n\t\t\t\tconst neighbours = myConnections.get(lastTile);\n\t\t\t\tif (neighbours === undefined) {\n\t\t\t\t\tthrow `Could not find connections data for tile ${lastTile}`;\n\t\t\t\t}\n\t\t\t\tfor (let neighbour of neighbours) {\n\t\t\t\t\tif (neighbour === fromTile) {\n\t\t\t\t\t\tif (path.length > 2) {\n\t\t\t\t\t\t\t// successful loop\n\t\t\t\t\t\t\treturn path;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (path.slice(1).some((x) => x === neighbour)) {\n\t\t\t\t\t\t// already been here\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpaths.push([...path, neighbour]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\t\twhile (inLoops.size < myConnections.size) {\n\t\t\t// console.log('myconnections', myConnections.size, ', in loops', inLoops.size)\n\t\t\tlet tileToCheck = -1;\n\t\t\tfor (let tile of myConnections.keys()) {\n\t\t\t\tif (!inLoops.has(tile)) {\n\t\t\t\t\ttileToCheck = tile;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// console.log('checking tile', tileToCheck)\n\t\t\tconst neighbours = myConnections.get(tileToCheck);\n\t\t\tif (neighbours === undefined) {\n\t\t\t\tthrow `Could not find connections data for tile ${tileToCheck}`;\n\t\t\t}\n\t\t\tconst neighbour = neighbours.values().next().value;\n\t\t\t// console.log('checking neighbour', neighbour)\n\t\t\tconst loop = traceLoopPath(tileToCheck, neighbour);\n\t\t\t// console.log('found loop', loop)\n\t\t\tif (loop.length === 0) {\n\t\t\t\t// no loop found\n\t\t\t\tneighbours.delete(neighbour);\n\t\t\t\tconst nConn = myConnections.get(neighbour);\n\t\t\t\tif (nConn === undefined) {\n\t\t\t\t\tthrow `Could not find connections data for tile ${neighbour}`;\n\t\t\t\t}\n\t\t\t\tnConn.delete(tileToCheck);\n\t\t\t\ttoPrune.add(neighbour).add(tileToCheck);\n\t\t\t\tpruneDeadEnds();\n\t\t\t} else {\n\t\t\t\tloop.forEach((i) => inLoops.add(i));\n\t\t\t}\n\t\t}\n\t\treturn inLoops;\n\t};\n\n\tself.findConnectedTiles = function (fromIndex, toIndex) {\n\t\tlet tileToCheck = new Set([{ fromIndex: fromIndex, tileIndex: toIndex }]);\n\t\tconst myComponent = self.components.get(toIndex);\n\t\t/** @type {Set<Number>} */\n\t\tconst checked = new Set([]);\n\t\twhile (tileToCheck.size > 0) {\n\t\t\t/** @type {Set<{fromIndex: Number, tileIndex: Number}>} */\n\t\t\tconst newChecks = new Set([]);\n\t\t\tfor (let { fromIndex, tileIndex } of tileToCheck) {\n\t\t\t\tconst neighbours = self.connections.get(tileIndex);\n\t\t\t\tif (neighbours === undefined) {\n\t\t\t\t\tthrow `Could not find connections data for tile ${tileIndex}`;\n\t\t\t\t}\n\t\t\t\tfor (let neighbour of neighbours) {\n\t\t\t\t\tif (neighbour === -1) {\n\t\t\t\t\t\t// no neighbour\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst neighbourComponent = self.components.get(neighbour);\n\t\t\t\t\tif (neighbourComponent === undefined) {\n\t\t\t\t\t\tthrow `Could not find component for tile ${neighbour}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (neighbourComponent !== myComponent) {\n\t\t\t\t\t\t// not from this component, will be handled during merge phase\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst neighbourConnections = self.connections.get(neighbour);\n\t\t\t\t\tif (neighbourConnections === undefined) {\n\t\t\t\t\t\tthrow `Could not find connections data for tile ${neighbour}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (!neighbourConnections.has(tileIndex)) {\n\t\t\t\t\t\t// not mutual\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (neighbour === fromIndex) {\n\t\t\t\t\t\t// came from here\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (checked.has(neighbour)) {\n\t\t\t\t\t\t// it's a loop?\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tnewChecks.add({ fromIndex: tileIndex, tileIndex: neighbour });\n\t\t\t\t}\n\t\t\t\tchecked.add(tileIndex);\n\t\t\t\ttileToCheck = newChecks;\n\t\t\t}\n\t\t}\n\t\treturn checked;\n\t};\n\n\treturn self;\n}\n","export class RegularPolygonTile {\n\t/**\n\t *\n\t * @param {Number} num_directions\n\t * @param {Number} angle_offset\n\t * @param {Number} radius_in\n\t * @param {Number[]} directions\n\t */\n\tconstructor(num_directions, angle_offset, radius_in, directions = [], border_width = 0.01) {\n\t\tthis.num_directions = num_directions;\n\t\tthis.angle_offset = angle_offset;\n\t\tthis.angle_unit = (Math.PI * 2) / num_directions;\n\t\tthis.radius_in = radius_in;\n\t\tthis.radius_out = radius_in / Math.cos(this.angle_unit / 2);\n\t\tthis.side_length = 2 * this.radius_out * Math.sin(this.angle_unit / 2);\n\t\tif (directions.length === num_directions) {\n\t\t\tthis.directions = [...directions];\n\t\t} else if (directions.length === 0) {\n\t\t\tthis.directions = [...Array(num_directions).keys()].map((x) => 2 ** x);\n\t\t} else {\n\t\t\tthrow `Length of directions ${directions} does not match directions number ${num_directions}`;\n\t\t}\n\t\t/** @type {Map<Number, Number>} */\n\t\tthis.direction_to_index = new Map(\n\t\t\tthis.directions.map((direction, index) => [direction, index])\n\t\t);\n\t\tthis.fully_connected = this.directions.reduce((a, b) => a + b, 0);\n\n\t\t// draw tile contour\n\t\tlet angle = angle_offset - this.angle_unit / 2;\n\t\tconst r = this.radius_out - border_width;\n\t\tthis.contour_path = `m ${r * Math.cos(angle)} ${-r * Math.sin(angle)}`;\n\t\tfor (let i = 1; i <= this.num_directions; i++) {\n\t\t\tangle += this.angle_unit;\n\t\t\tthis.contour_path += ` L ${r * Math.cos(angle)} ${-r * Math.sin(angle)}`;\n\t\t}\n\t\tthis.contour_path += ' z';\n\n\t\t// caches for frequently recomputed values\n\t\tthis.cache = {\n\t\t\trotate: new Map(),\n\t\t\tpipes_path: new Map(),\n\t\t\tguide_dot_position: new Map(),\n\t\t\tedgemark_line: new Map()\n\t\t};\n\t}\n\n\t/**\n\t * Return mininum equivalent number of rotations\n\t * In case of 4 directions rotating +3 is the same as rotating -1\n\t * So the only unique rotations are -1, 0, 1, 2\n\t * @param {Number} times\n\t */\n\tnormalize_rotations(times) {\n\t\ttimes = times % this.num_directions;\n\t\tconst half = this.num_directions / 2;\n\t\tif (times <= -half) {\n\t\t\ttimes += this.num_directions;\n\t\t} else if (times > half) {\n\t\t\ttimes -= this.num_directions;\n\t\t}\n\t\treturn times;\n\t}\n\n\t/**\n\t * Return the result of rotating a tile a number of times\n\t * @param {Number} tile\n\t * @param {Number} times\n\t * @returns {Number}\n\t */\n\trotate(tile, times) {\n\t\ttimes = this.normalize_rotations(times);\n\t\tconst key = [tile, times].join('_');\n\t\tconst cached = this.cache.rotate.get(key);\n\t\tif (cached !== undefined) {\n\t\t\treturn cached;\n\t\t}\n\t\tlet result = 0;\n\t\tfor (let [index, direction] of this.directions.entries()) {\n\t\t\tif ((direction & tile) === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst rotated_index = (index + this.num_directions - times) % this.num_directions;\n\t\t\tresult += this.directions[rotated_index];\n\t\t}\n\t\tthis.cache.rotate.set(key, result);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get angle in radians corresponding to a certain number of rotations\n\t * @param {Number} rotations\n\t * @returns {Number}\n\t */\n\tget_angle(rotations) {\n\t\treturn this.angle_unit * rotations;\n\t}\n\n\t/**\n\t * Which directions a tile is pointing to after some rotations\n\t * @param {Number} tile\n\t * @param {Number} rotations\n\t * @returns\n\t */\n\tget_directions(tile, rotations) {\n\t\tlet rotated = tile;\n\t\tif (rotations !== 0) {\n\t\t\trotated = this.rotate(tile, rotations);\n\t\t}\n\t\treturn this.directions.filter((x) => (x & rotated) > 0);\n\t}\n\n\t/**\n\t * A path to draw the pipes\n\t * @param {Number} tile\n\t */\n\tget_pipes_path(tile) {\n\t\tconst cached = this.cache.pipes_path.get(tile);\n\t\tif (cached !== undefined) {\n\t\t\treturn cached;\n\t\t}\n\t\tlet path = `M 0 0`;\n\t\tthis.directions.forEach((direction, index) => {\n\t\t\tif ((direction & tile) > 0) {\n\t\t\t\tconst angle = this.angle_offset + this.angle_unit * index;\n\t\t\t\tconst dx = this.radius_in * Math.cos(angle);\n\t\t\t\tconst dy = this.radius_in * Math.sin(angle);\n\t\t\t\tpath += ` l ${dx} ${-dy} L 0 0`;\n\t\t\t}\n\t\t});\n\t\tthis.cache.pipes_path.set(tile, path);\n\t\treturn path;\n\t}\n\n\t/**\n\t * Where to draw a guiding dot for a tile\n\t * @param {Number} tile\n\t */\n\tget_guide_dot_position(tile) {\n\t\tconst cached = this.cache.guide_dot_position.get(tile);\n\t\tif (cached !== undefined) {\n\t\t\treturn cached;\n\t\t}\n\t\tlet dx = 0,\n\t\t\tdy = 0,\n\t\t\tn = 0;\n\t\tconst legs = [];\n\t\tfor (let [index, direction] of this.directions.entries()) {\n\t\t\tif ((tile & direction) === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tn += 1;\n\t\t\tconst angle = this.angle_offset + this.angle_unit * index;\n\t\t\tconst leg = {\n\t\t\t\tdx: this.radius_in * Math.cos(angle),\n\t\t\t\tdy: this.radius_in * Math.sin(angle),\n\t\t\t\tindex,\n\t\t\t\tdirection,\n\t\t\t\tangle\n\t\t\t};\n\t\t\tdx += leg.dx;\n\t\t\tdy += leg.dy;\n\t\t\tlegs.push(leg);\n\t\t}\n\t\tdx /= n;\n\t\tdy /= n;\n\t\tif (Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001) {\n\t\t\t// a symmetric tile - I, X, Y or fully connected\n\t\t\tif (legs.length <= 3 || legs.length === this.num_directions) {\n\t\t\t\t// I or Y or fully connected tile\n\t\t\t\t// grab any leg\n\t\t\t\tdx = legs[0].dx;\n\t\t\t\tdy = legs[0].dy;\n\t\t\t} else {\n\t\t\t\tconst distances = legs.map((leg, i, legs) => {\n\t\t\t\t\tconst next_leg = legs[(i + 1) % legs.length];\n\t\t\t\t\treturn Math.abs(this.normalize_rotations(leg.index - next_leg.index));\n\t\t\t\t});\n\t\t\t\tif (distances.slice(1).every((x) => x === distances[0])) {\n\t\t\t\t\t// octagonal + tile, no direction is better than the others\n\t\t\t\t\t// grab any leg\n\t\t\t\t\tdx = legs[0].dx;\n\t\t\t\t\tdy = legs[0].dy;\n\t\t\t\t} else {\n\t\t\t\t\t// X,  and the like\n\t\t\t\t\t// cut off \"top\" half of X and get the guide dot for that\n\t\t\t\t\tconst half = legs.length / 2;\n\t\t\t\t\tconst distance_sums = distances.map((d) => 0);\n\t\t\t\t\tfor (let i = 0; i < half; i++) {\n\t\t\t\t\t\tconst multiple = this.num_directions ** (half - i - 1);\n\t\t\t\t\t\tfor (let sum_index of distance_sums.keys()) {\n\t\t\t\t\t\t\tdistance_sums[sum_index] += multiple * distances[(sum_index + i) % legs.length];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst min_sum = Math.min(...distance_sums);\n\t\t\t\t\tconst base_leg_index = distance_sums.indexOf(min_sum);\n\t\t\t\t\tfor (let leg of legs.slice(base_leg_index, base_leg_index + half)) {\n\t\t\t\t\t\tdx += leg.dx;\n\t\t\t\t\t\tdy += leg.dy;\n\t\t\t\t\t}\n\t\t\t\t\tdx /= half;\n\t\t\t\t\tdy /= half;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst l = Math.sqrt(dx * dx + dy * dy);\n\t\tconst result = [(this.radius_in * dx) / l, (this.radius_in * dy) / l];\n\t\tthis.cache.guide_dot_position.set(tile, result);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compute number of rotations for orienting a tile with \"click to orient\" control mode\n\t * @param {Number} tile\n\t * @param {Number} old_rotations\n\t * @param {Number} new_angle\n\t * @returns {Number}\n\t */\n\tclick_orient_tile(tile, old_rotations, new_angle) {\n\t\tconst [guideX, guideY] = this.get_guide_dot_position(tile);\n\t\tconst old_angle = Math.atan2(guideY, guideX);\n\t\tlet times_rotate =\n\t\t\t(Math.round((old_angle - new_angle) / this.angle_unit) - old_rotations) % this.num_directions;\n\t\tconst half = this.num_directions / 2;\n\t\tif (times_rotate > half) {\n\t\t\ttimes_rotate -= this.num_directions;\n\t\t} else if (times_rotate < -half) {\n\t\t\ttimes_rotate += this.num_directions;\n\t\t}\n\t\treturn times_rotate;\n\t}\n\n\t/**\n\t * Detects gesture for drawing wall or connection marks\n\t * Coordinates should be relative to tile center\n\t * @param {Number} x1\n\t * @param {Number} x2\n\t * @param {Number} y1\n\t * @param {Number} y2\n\t */\n\tdetect_edgemark_gesture(x1, x2, y1, y2) {\n\t\tlet start_angle = Math.atan2(y1, x1);\n\t\tlet end_angle = Math.atan2(y2, x2);\n\t\tstart_angle += start_angle < 0 ? 2 * Math.PI : 0;\n\t\tend_angle += end_angle < 0 ? 2 * Math.PI : 0;\n\t\tlet delta_angle = Math.abs(start_angle - end_angle);\n\t\tlet mean_angle = 0.5 * (start_angle + end_angle);\n\t\tif (delta_angle > Math.PI) {\n\t\t\tdelta_angle = 2 * Math.PI - delta_angle;\n\t\t\tmean_angle -= Math.PI;\n\t\t}\n\t\tconst direction_index = Math.round((mean_angle - this.angle_offset) / this.angle_unit);\n\t\tconst start_radius = Math.sqrt(y1 ** 2 + x1 ** 2);\n\t\tconst end_radius = Math.sqrt(y2 ** 2 + x2 ** 2);\n\t\tconst mean_radius = 0.5 * (start_radius + end_radius);\n\n\t\tconst radius_is_close = Math.abs(mean_radius - this.radius_in) <= 0.4 * this.radius_in;\n\t\tconst angle_is_close =\n\t\t\tMath.abs(mean_angle - (this.angle_offset + direction_index * this.angle_unit)) <=\n\t\t\t0.5 * this.angle_unit;\n\t\t/** @type {{mark:import('$lib/puzzle/game').EdgeMark, direction: Number}} */\n\t\tconst result = {\n\t\t\tmark: 'none',\n\t\t\tdirection: this.directions[(direction_index + this.num_directions) % this.num_directions]\n\t\t};\n\n\t\tif (radius_is_close && angle_is_close) {\n\t\t\t// was close to tile border\n\t\t\t// in a well defined direction\n\t\t\t// toggle an edgemark here\n\t\t\tconst distance_along_border = this.radius_in * delta_angle;\n\t\t\tconst distance_across_border = Math.abs(start_radius - end_radius);\n\t\t\tif (distance_along_border > distance_across_border) {\n\t\t\t\tresult.mark = 'wall';\n\t\t\t} else if (distance_along_border < distance_across_border) {\n\t\t\t\tresult.mark = 'conn';\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Tells if a point is close to the middle of a polygon's edge\n\t * Input coordinates are relative to tile's center\n\t * @param {Number} x\n\t * @param {Number} y\n\t */\n\tis_close_to_edge(x, y) {\n\t\tconst delta_radius = Math.abs(Math.sqrt(x ** 2 + y ** 2) - this.radius_in);\n\t\tlet angle = Math.atan2(y, x);\n\t\tangle += angle < 0 ? 2 * Math.PI : 0;\n\t\tconst direction_index = Math.round((angle - this.angle_offset) / this.angle_unit);\n\t\tconst direction_angle = this.angle_offset + this.angle_unit * direction_index;\n\t\tlet delta_angle = Math.abs(angle - direction_angle);\n\t\tdelta_angle = Math.min(delta_angle, 2 * Math.PI - delta_angle);\n\t\tconst direction =\n\t\t\tthis.directions[(direction_index + this.num_directions) % this.num_directions];\n\t\treturn {\n\t\t\tdirection,\n\t\t\tisClose: delta_radius <= 0.3 * this.radius_in && delta_angle <= 0.3 * this.angle_unit\n\t\t};\n\t}\n\n\t/**\n\t * Returns coordinates for drawing edgemark line relative to tile center\n\t * @param {Number} direction\n\t */\n\tget_edgemark_line(direction) {\n\t\tconst cached = this.cache.edgemark_line.get(direction);\n\t\tif (cached !== undefined) {\n\t\t\treturn cached;\n\t\t}\n\t\tconst index = this.direction_to_index.get(direction) || 0;\n\t\tconst angle = this.angle_offset + index * this.angle_unit;\n\t\tconst ax = Math.cos(angle);\n\t\tconst ay = Math.sin(angle);\n\t\tconst offset_x = ax * this.radius_in;\n\t\tconst offset_y = ay * this.radius_in;\n\t\tconst dx = 0.25 * this.side_length * ax;\n\t\tconst dy = 0.25 * this.side_length * ay;\n\t\tconst line = {\n\t\t\tx1: offset_x - dx,\n\t\t\ty1: -offset_y + dy,\n\t\t\tx2: offset_x + dx,\n\t\t\ty2: -offset_y - dy\n\t\t};\n\t\tthis.cache.edgemark_line.set(direction, line);\n\t\treturn line;\n\t}\n}\n","import { RegularPolygonTile } from './polygonutils';\n\nconst EAST = 1;\nconst NORTHEAST = 2;\nconst NORTHWEST = 4;\nconst WEST = 8;\nconst SOUTHWEST = 16;\nconst SOUTHEAST = 32;\n\nconst YSTEP = Math.sqrt(3) / 2;\n\nconst HEXAGON = new RegularPolygonTile(6, 0, 0.5);\n\nexport class HexaGrid {\n\tDIRECTIONS = [EAST, NORTHEAST, NORTHWEST, WEST, SOUTHWEST, SOUTHEAST];\n\tEDGEMARK_DIRECTIONS = [NORTHEAST, NORTHWEST, WEST];\n\tOPPOSITE = new Map([\n\t\t[NORTHEAST, SOUTHWEST],\n\t\t[SOUTHWEST, NORTHEAST],\n\t\t[EAST, WEST],\n\t\t[WEST, EAST],\n\t\t[NORTHWEST, SOUTHEAST],\n\t\t[SOUTHEAST, NORTHWEST]\n\t]);\n\tNUM_DIRECTIONS = 6;\n\tKIND = 'hexagonal';\n\tPIPE_WIDTH = 0.12;\n\tSTROKE_WIDTH = 0.05;\n\tPIPE_LENGTH = 0.5;\n\tSINK_RADIUS = 0.17;\n\n\t/** @type {Set<Number>} - indices of empty cells */\n\temptyCells;\n\t/** @type {Number} - total number of cells including empties */\n\ttotal;\n\n\t#RC_DELTA = new Map([\n\t\t[\n\t\t\tEAST,\n\t\t\t[\n\t\t\t\t[0, 1],\n\t\t\t\t[0, 1]\n\t\t\t]\n\t\t],\n\t\t[\n\t\t\tNORTHEAST,\n\t\t\t[\n\t\t\t\t[-1, 0],\n\t\t\t\t[-1, 1]\n\t\t\t]\n\t\t],\n\t\t[\n\t\t\tNORTHWEST,\n\t\t\t[\n\t\t\t\t[-1, -1],\n\t\t\t\t[-1, 0]\n\t\t\t]\n\t\t],\n\t\t[\n\t\t\tWEST,\n\t\t\t[\n\t\t\t\t[0, -1],\n\t\t\t\t[0, -1]\n\t\t\t]\n\t\t],\n\t\t[\n\t\t\tSOUTHWEST,\n\t\t\t[\n\t\t\t\t[1, -1],\n\t\t\t\t[1, 0]\n\t\t\t]\n\t\t],\n\t\t[\n\t\t\tSOUTHEAST,\n\t\t\t[\n\t\t\t\t[1, 0],\n\t\t\t\t[1, 1]\n\t\t\t]\n\t\t]\n\t]);\n\n\t/**\n\t *\n\t * @param {Number} width\n\t * @param {Number} height\n\t * @param {Boolean} wrap\n\t * @param {Number[]} tiles\n\t */\n\tconstructor(width, height, wrap, tiles = []) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.wrap = wrap;\n\n\t\tthis.emptyCells = new Set();\n\t\ttiles.forEach((tile, index) => {\n\t\t\tif (tile === 0) {\n\t\t\t\tthis.emptyCells.add(index);\n\t\t\t}\n\t\t});\n\t\tthis.total = width * height;\n\n\t\tthis.XMIN = -0.6 - (wrap ? 1 : 0);\n\t\tthis.XMAX = width + 0.1 + (wrap ? 1 : 0);\n\t\tthis.YMIN = -YSTEP * (1 + (wrap ? 1 : 0));\n\t\tthis.YMAX = YSTEP * (height + (wrap ? 1 : 0));\n\n\t\t/* Tile types for use in solver */\n\t\tthis.T0 = 0;\n\t\tthis.T1 = 1;\n\t\tthis.T2v = 3;\n\t\tthis.T2c = 5;\n\t\tthis.T2I = 9;\n\t\tthis.T3w = 7;\n\t\tthis.T3y = 11;\n\t\tthis.T3la = 13;\n\t\tthis.T3Y = 21;\n\t\tthis.T4K = 15;\n\t\tthis.T4X = 27;\n\t\tthis.T4psi = 23;\n\t\tthis.T5 = 31;\n\t\tthis.T6 = 63;\n\t\t/** @type {Map<Number,Number>} */\n\t\tthis.tileTypes = new Map();\n\t\tfor (let t = 0; t < 64; t++) {\n\t\t\tlet rotated = t;\n\t\t\twhile (!this.tileTypes.has(rotated)) {\n\t\t\t\tthis.tileTypes.set(rotated, t);\n\t\t\t\trotated = this.rotate(rotated, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Number} index\n\t */\n\tindex_to_xy(index) {\n\t\tconst c = index % this.width;\n\t\tconst r = Math.round((index - c) / this.width);\n\t\tconst x = c + (r % 2 === 0 ? 0.0 : 0.5);\n\t\tconst y = r * YSTEP;\n\t\treturn [x, y];\n\t}\n\n\t/**\n\t * Determines which tile a point at (x, y) belongs to\n\t * Returns tile index and tile center coordinates\n\t * If the point is over empty space then tileIndex is -1\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @returns {{index: Number, x:Number, y: Number}}\n\t */\n\twhich_tile_at(x, y) {\n\t\tconst r = y / YSTEP;\n\t\tconst r0 = Math.round(r);\n\t\tconst c0 = Math.round(x - (r0 % 2 === 0 ? 0 : 0.5));\n\t\tconst x0 = c0 + (r0 % 2 === 0 ? 0.0 : 0.5);\n\t\tconst y0 = r0 * YSTEP;\n\t\tconst distance0 = Math.sqrt((x - x0) ** 2 + (y - y0) ** 2);\n\t\tif (distance0 <= 0.5) {\n\t\t\treturn {\n\t\t\t\tindex: this.rc_to_index(r0, c0),\n\t\t\t\tx: x0,\n\t\t\t\ty: y0\n\t\t\t};\n\t\t} else {\n\t\t\tlet r1 = Math.floor(r);\n\t\t\tif (r1 === r0) {\n\t\t\t\tr1 = Math.ceil(r);\n\t\t\t}\n\t\t\tconst c1 = Math.round(x - (r1 % 2 === 0 ? 0 : 0.5));\n\t\t\tconst x1 = c1 + (r1 % 2 === 0 ? 0.0 : 0.5);\n\t\t\tconst y1 = r1 * YSTEP;\n\t\t\tconst distance1 = Math.sqrt((x - x1) ** 2 + (y - y1) ** 2);\n\t\t\tif (distance0 < distance1) {\n\t\t\t\treturn {\n\t\t\t\t\tindex: this.rc_to_index(r0, c0),\n\t\t\t\t\tx: x0,\n\t\t\t\t\ty: y0\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tindex: this.rc_to_index(r1, c1),\n\t\t\t\t\tx: x1,\n\t\t\t\t\ty: y1\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Number} index\n\t * @param {Number} direction\n\t * @returns {{neighbour: Number, empty: boolean}} - neighbour index, is the neighbour an empty cell or outside the board\n\t */\n\tfind_neighbour(index, direction) {\n\t\tlet c = index % this.width;\n\t\tlet r = (index - c) / this.width;\n\t\tlet neighbour = -1;\n\n\t\tconst [dr, dc] = (this.#RC_DELTA.get(direction) || [[]])[r % 2];\n\t\tr += dr;\n\t\tc += dc;\n\t\tif (this.wrap) {\n\t\t\tif (r == -1) {\n\t\t\t\tr = this.height - 1;\n\t\t\t\tc += 1;\n\t\t\t}\n\t\t\tif (r == this.height) {\n\t\t\t\tr = 0;\n\t\t\t\tc -= 1 - (this.height % 2);\n\t\t\t}\n\t\t\tif (c < 0 || c === this.width) {\n\t\t\t\tc = (c + this.width) % this.width;\n\t\t\t}\n\t\t}\n\t\tif (r < 0 || r >= this.height) {\n\t\t\tneighbour = -1;\n\t\t} else if (c < 0 || c >= this.width) {\n\t\t\tneighbour = -1;\n\t\t} else {\n\t\t\tneighbour = this.width * r + c;\n\t\t}\n\t\tconst empty = neighbour === -1 || this.emptyCells.has(neighbour);\n\t\treturn { neighbour, empty };\n\t}\n\n\t/**\n\t * Get index of tile located at row r column c\n\t * @param {Number} r\n\t * @param {Number} c\n\t * @returns {Number}\n\t */\n\trc_to_index(r, c) {\n\t\tif (this.wrap) {\n\t\t\twhile (r < 0) {\n\t\t\t\tconst evenRow = r % 2 === 0;\n\t\t\t\tr += this.height;\n\t\t\t\tif (this.height % 2 !== 0) {\n\t\t\t\t\tc += evenRow ? 0 : 1;\n\t\t\t\t} else {\n\t\t\t\t\tc += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (r >= this.height) {\n\t\t\t\tconst evenRow = r % 2 === 0;\n\t\t\t\tr -= this.height;\n\t\t\t\tif (this.height % 2 !== 0) {\n\t\t\t\t\tc -= evenRow ? 1 : 0;\n\t\t\t\t} else {\n\t\t\t\t\tc -= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc = c % this.width;\n\t\t\tif (c < 0) {\n\t\t\t\tc += this.width;\n\t\t\t}\n\t\t} else if (r < 0 || r >= this.height || c < 0 || c >= this.width) {\n\t\t\treturn -1;\n\t\t}\n\t\tconst index = this.width * r + c;\n\t\tif (this.emptyCells.has(index)) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn index;\n\t}\n\n\t/**\n\t * Makes cell at index empty\n\t * @param {Number} index\n\t */\n\tmakeEmpty(index) {\n\t\tthis.emptyCells.add(index);\n\t}\n\n\t/**\n\t * A number corresponding to fully connected tile\n\t * @param {Number} index\n\t * @returns {Number}\n\t */\n\tfullyConnected(index) {\n\t\treturn 63;\n\t}\n\n\t/**\n\t * Compute tile orientation after a number of rotations\n\t * @param {Number} tile\n\t * @param {Number} rotations\n\t * @param {Number} index - index of tile, not used here\n\t * @returns\n\t */\n\trotate(tile, rotations, index = 0) {\n\t\treturn HEXAGON.rotate(tile, rotations);\n\t}\n\n\t/**\n\t * Get angle for displaying rotated pipes state\n\t * @param {Number} rotations\n\t * @param {Number} index\n\t * @returns\n\t */\n\tgetAngle(rotations, index) {\n\t\treturn HEXAGON.get_angle(rotations);\n\t}\n\n\t/**\n\t *\n\t * @param {Number} tile\n\t * @param {Number} rotations\n\t * @param {Number} index\n\t * @returns {Number[]}\n\t */\n\tgetDirections(tile, rotations = 0, index = 0) {\n\t\treturn HEXAGON.get_directions(tile, rotations);\n\t}\n\n\t/**\n\t * @param {import('$lib/puzzle/viewbox').ViewBox} box\n\t * @returns {import('$lib/puzzle/viewbox').VisibleTile[]}\n\t */\n\tgetVisibleTiles(box) {\n\t\tlet rmin = Math.floor(box.ymin / YSTEP) - 1;\n\t\tlet rmax = Math.ceil((box.ymin + box.height) / YSTEP) + 1;\n\t\tif (!this.wrap) {\n\t\t\trmin = Math.max(0, rmin);\n\t\t\trmax = Math.min(this.height - 1, rmax);\n\t\t}\n\t\tlet cmin = Math.floor(box.xmin - (rmin % 2 === 0 ? 0 : 0.5)) - 1;\n\t\tlet cmax = Math.ceil(box.xmin + box.width - (rmin % 2 === 0 ? 0 : 0.5)) + 1;\n\t\tif (!this.wrap) {\n\t\t\tcmin = Math.max(0, cmin);\n\t\t\tcmax = Math.min(this.width - 1, cmax);\n\t\t}\n\t\tconst visibleTiles = [];\n\t\tfor (let r = rmin; r <= rmax; r++) {\n\t\t\tfor (let c = cmin; c <= cmax; c++) {\n\t\t\t\tconst index = this.rc_to_index(r, c);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst x = c + (r % 2 === 0 ? 0.0 : 0.5);\n\t\t\t\tconst y = r * YSTEP;\n\t\t\t\tconst key = `${Math.round(10 * x)}_${Math.round(10 * y)}`;\n\t\t\t\tvisibleTiles.push({\n\t\t\t\t\tindex,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\tkey\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn visibleTiles;\n\t}\n\n\t/**\n\t * Shape the playing field by making some tiles empty\n\t * @param {'hexagon'|'triangle'|'hourglass'} shape\n\t */\n\tuseShape(shape) {\n\t\tif (shape === 'hexagon') {\n\t\t\tconst wrap = this.wrap;\n\t\t\tthis.wrap = false;\n\t\t\tconst middle_row = Math.floor(this.height / 2);\n\t\t\tlet left_cell = this.width * middle_row;\n\t\t\tlet right_cell = left_cell + this.width - 1;\n\t\t\tfor (let [start_cell, shift_direction, erase_direction] of [\n\t\t\t\t[left_cell, NORTHEAST, WEST],\n\t\t\t\t[right_cell, NORTHWEST, EAST],\n\t\t\t\t[left_cell, SOUTHEAST, WEST],\n\t\t\t\t[right_cell, SOUTHWEST, EAST]\n\t\t\t]) {\n\t\t\t\tlet cell = start_cell;\n\t\t\t\tfor (let delta_row = 1; delta_row < middle_row + 1; delta_row++) {\n\t\t\t\t\tlet new_cell = this.find_neighbour(cell, shift_direction);\n\t\t\t\t\tif (new_cell.empty) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcell = new_cell.neighbour;\n\t\t\t\t\t}\n\t\t\t\t\tlet { neighbour, empty } = this.find_neighbour(cell, erase_direction);\n\t\t\t\t\twhile (!empty) {\n\t\t\t\t\t\tthis.makeEmpty(neighbour);\n\t\t\t\t\t\t({ neighbour, empty } = this.find_neighbour(neighbour, erase_direction));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.wrap = wrap;\n\t\t} else if (shape === 'triangle') {\n\t\t\tconst wrap = this.wrap;\n\t\t\tthis.wrap = false;\n\t\t\tlet left_cell = 0;\n\t\t\tlet right_cell = this.width - 1;\n\t\t\tfor (let [start_cell, shift_direction, erase_direction] of [\n\t\t\t\t[left_cell, SOUTHEAST, WEST],\n\t\t\t\t[right_cell, SOUTHWEST, EAST]\n\t\t\t]) {\n\t\t\t\tlet cell = start_cell;\n\t\t\t\twhile (true) {\n\t\t\t\t\tlet new_cell = this.find_neighbour(cell, shift_direction);\n\t\t\t\t\tif (new_cell.empty) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcell = new_cell.neighbour;\n\t\t\t\t\t}\n\t\t\t\t\tlet { neighbour, empty } = this.find_neighbour(cell, erase_direction);\n\t\t\t\t\twhile (!empty) {\n\t\t\t\t\t\tthis.makeEmpty(neighbour);\n\t\t\t\t\t\t({ neighbour, empty } = this.find_neighbour(neighbour, erase_direction));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.wrap = wrap;\n\t\t} else if (shape === 'hourglass') {\n\t\t\tconsole.log('hourglass');\n\t\t\tconst wrap = this.wrap;\n\t\t\tthis.wrap = false;\n\t\t\tconst middle_row = Math.floor(this.height / 2);\n\t\t\tfor (let [start_cell, shift_direction, erase_direction] of [\n\t\t\t\t[0, SOUTHEAST, WEST],\n\t\t\t\t[this.width - 1, SOUTHWEST, EAST],\n\t\t\t\t[this.width * (this.height - 1), NORTHEAST, WEST],\n\t\t\t\t[this.width * this.height - 1, NORTHWEST, EAST]\n\t\t\t]) {\n\t\t\t\tlet cell = start_cell;\n\t\t\t\tfor (let delta_row = 1; delta_row < middle_row + 1; delta_row++) {\n\t\t\t\t\tlet new_cell = this.find_neighbour(cell, shift_direction);\n\t\t\t\t\tif (new_cell.empty) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcell = new_cell.neighbour;\n\t\t\t\t\t}\n\t\t\t\t\tlet { neighbour, empty } = this.find_neighbour(cell, erase_direction);\n\t\t\t\t\twhile (!empty) {\n\t\t\t\t\t\tthis.makeEmpty(neighbour);\n\t\t\t\t\t\t({ neighbour, empty } = this.find_neighbour(neighbour, erase_direction));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.wrap = wrap;\n\t\t} else {\n\t\t\tthrow 'unknown shape ' + shape;\n\t\t}\n\t}\n\n\t/**\n\t * Tile contour path for svg drawing\n\t * @param {Number} index\n\t * @returns\n\t */\n\tgetTilePath(index) {\n\t\treturn HEXAGON.contour_path;\n\t}\n\n\t/**\n\t * Pipes lines path\n\t * @param {Number} tile\n\t * @param {Number} index\n\t */\n\tgetPipesPath(tile, index) {\n\t\treturn HEXAGON.get_pipes_path(tile);\n\t}\n\n\t/**\n\t * Computes position for drawing the tile guiding dot\n\t * @param {Number} tile\n\t * @param {Number} index\n\t * @returns {Number[]}\n\t */\n\tgetGuideDotPosition(tile, index = 0) {\n\t\tconst [dx, dy] = HEXAGON.get_guide_dot_position(tile);\n\t\treturn [0.8 * dx, 0.8 * dy];\n\t}\n\t/**\n\t * Compute number of rotations for orienting a tile with \"click to orient\" control mode\n\t * @param {Number} tile\n\t * @param {Number} old_rotations\n\t * @param {Number} new_angle\n\t * @param {Number} index\n\t */\n\tclickOrientTile(tile, old_rotations, new_angle, index = 0) {\n\t\treturn HEXAGON.click_orient_tile(tile, old_rotations, new_angle);\n\t}\n\n\t/**\n\t * Returns coordinates of endpoints of edgemark line\n\t * @param {Number} direction\n\t * @param {Number} index\n\t * @returns\n\t */\n\tgetEdgemarkLine(direction, index = 0) {\n\t\treturn HEXAGON.get_edgemark_line(direction);\n\t}\n\n\t/**\n\t * Check if a drag gesture resembles drawing an edge mark\n\t * @param {Number} tile_index\n\t * @param {Number} tile_x\n\t * @param {Number} tile_y\n\t * @param {Number} x1\n\t * @param {Number} x2\n\t * @param {Number} y1\n\t * @param {Number} y2\n\t */\n\tdetectEdgemarkGesture(tile_index, tile_x, tile_y, x1, x2, y1, y2) {\n\t\treturn HEXAGON.detect_edgemark_gesture(x1 - tile_x, x2 - tile_x, tile_y - y1, tile_y - y2);\n\t}\n\n\t/**\n\t * Tells if a point is close to one of tile's edges\n\t * @param {import('$lib/puzzle/controls').PointerOrigin} point\n\t */\n\twhichEdge(point) {\n\t\tconst { x, y, tileX, tileY } = point;\n\t\tconst dx = x - tileX;\n\t\tconst dy = tileY - y;\n\t\treturn HEXAGON.is_close_to_edge(dx, dy);\n\t}\n}\n","import { HexaGrid } from './grids/hexagrid';\n\n/* Constraint Violation Exceptions */\n\n/**\n * A cell has no more viable orientations\n * @param {Cell} cell\n */\nfunction NoOrientationsPossibleException(cell) {\n\tthis.name = 'NoOrientationsPossible';\n\tthis.message = `No orientations possible for tile ${cell.initial} at index ${cell.index}`;\n}\n\nfunction LoopDetectedException() {\n\tthis.name = 'LoopDetected';\n\tthis.message = 'Loop detected';\n}\n\nfunction IslandDetectedException() {\n\tthis.name = 'IslandDetected';\n\tthis.message = 'Island detected';\n}\n\n/**\n * Solving stage\n * initial: deductions made about the original puzzle\n * guess: deductions made after a guess\n * aftercheck: steps made after a solution has been found\n * @typedef {'initial'|'guess'|'aftercheck'} SolvingStage\n */\n\n/**\n * Solve step represents processing new info on a single cell\n * @typedef {Object} Step\n * @property {Number} index\n * @property {Number} orientation\n * @property {Boolean} final - true if this orientation is the only one left\n */\n\n/**\n * @constructor\n * @param {import('$lib/puzzle/grids/grids').Grid} grid\n * @param {Number} index - tile index in grid\n * @param {Number} initial - initial orientation\n */\nexport function Cell(grid, index, initial) {\n\tlet self = this;\n\tself.index = index;\n\tself.initial = initial;\n\n\tself.possible = new Set();\n\tif (initial >= 0) {\n\t\tlet rotated = initial;\n\t\twhile (!self.possible.has(rotated)) {\n\t\t\tself.possible.add(rotated);\n\t\t\trotated = grid.rotate(rotated, 1, index);\n\t\t}\n\t} else {\n\t\t// special case of null tile - can have any tile type/orientation\n\t\t// TODO let the grid supply this set depending on index\n\t\tself.possible = new Set();\n\t\tfor (let i = 1; i < grid.fullyConnected(index); i++) {\n\t\t\tself.possible.add(i);\n\t\t}\n\t}\n\tself.walls = 0;\n\tself.connections = 0;\n\n\t/**\n\t * @param {Number} direction\n\t */\n\tself.addWall = function (direction) {\n\t\tself.walls += direction - ((self.connections + self.walls) & direction);\n\t};\n\n\t/**\n\t * @param {Number} direction\n\t */\n\tself.addConnection = function (direction) {\n\t\tself.connections += direction - ((self.connections + self.walls) & direction);\n\t};\n\n\t/**\n\t * Removes orientations if they don't have all the mentioned walls\n\t * @param {Number} directions\n\t */\n\tself.mustHaveAllWalls = function (directions) {\n\t\tfor (let orientation of self.possible) {\n\t\t\tif ((orientation & directions) > 0) {\n\t\t\t\tself.possible.delete(orientation);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Removes orientations if they don't have at least one of the mentioned walls\n\t * @param {Number} directions\n\t */\n\tself.mustHaveSomeWalls = function (directions) {\n\t\tfor (let orientation of self.possible) {\n\t\t\tif ((orientation & directions) === orientation) {\n\t\t\t\tself.possible.delete(orientation);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Removes orientations if they don't have all the mentioned connections\n\t * @param {Number} directions\n\t */\n\tself.mustHaveAllConnections = function (directions) {\n\t\tfor (let orientation of self.possible) {\n\t\t\tif ((orientation & directions) !== directions) {\n\t\t\t\tself.possible.delete(orientation);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Filters out tile orientations that contradict known constraints\n\t * @throws {NoOrientationsPossible}\n\t * @returns {{addedWalls:Number, addedConnections: Number}}\n\t */\n\tself.applyConstraints = function () {\n\t\tconst newPossible = new Set();\n\t\tfor (let orientation of self.possible) {\n\t\t\tif (\n\t\t\t\t// respects known walls\n\t\t\t\t(orientation & self.walls) === 0 &&\n\t\t\t\t// respects known connections if any\n\t\t\t\t(orientation & self.connections) === self.connections\n\t\t\t) {\n\t\t\t\tnewPossible.add(orientation);\n\t\t\t}\n\t\t}\n\t\tself.possible = newPossible;\n\t\tif (newPossible.size === 0) {\n\t\t\tthrow new NoOrientationsPossibleException(self);\n\t\t}\n\t\tconst full = grid.fullyConnected(index);\n\t\tlet newWalls = full;\n\t\tlet newConnections = full;\n\t\tnewPossible.forEach((orientation) => {\n\t\t\tnewWalls = newWalls & (full - orientation);\n\t\t\tnewConnections = newConnections & orientation;\n\t\t});\n\t\tconst addedWalls = newWalls - self.walls;\n\t\tconst addedConnections = newConnections - self.connections;\n\t\tself.walls = newWalls;\n\t\tself.connections = newConnections;\n\t\treturn { addedWalls, addedConnections };\n\t};\n\n\t/**\n\t * Returns a copy of the cell\n\t * @returns {Cell}\n\t */\n\tself.clone = function () {\n\t\tconst clone = new Cell(grid, self.index, 0);\n\t\tclone.initial = self.initial;\n\t\tclone.possible = new Set(self.possible);\n\t\tclone.walls = self.walls;\n\t\tclone.connections = self.connections;\n\t\treturn clone;\n\t};\n\n\treturn self;\n}\n\n/**\n * @constructor\n * @param {Number[]} tiles - tile index in grid\n * @param {import('$lib/puzzle/grids/grids').Grid} grid\n */\nexport function Solver(tiles, grid) {\n\tlet self = this;\n\tself.tiles = tiles;\n\tself.grid = grid;\n\n\tself.UNSOLVED = -1;\n\tself.AMBIGUOUS = -2;\n\n\t/** @type {Map<Number, Cell>} */\n\tself.unsolved = new Map([]);\n\n\t/** @type {Map<Number, Set<Number>>} */\n\tself.components = new Map([]);\n\n\tconst directions = new Set(grid.DIRECTIONS);\n\n\t/** @type {Number[]} */\n\tself.solution = tiles.map(() => self.UNSOLVED);\n\n\t/** @type {Number[][]} */\n\tself.solutions = [];\n\n\t/** @type {Set<Number>} */\n\tself.dirty = new Set();\n\n\t// ruling out orientations connecting only deadends messes up\n\t// solving very small instances\n\t// so it's only enabled if there's enough tiles\n\tself.checkDeadendConnections = self.grid.total > self.grid.DIRECTIONS.length + 1;\n\n\t/**\n\t * Returns the cell at index. Initializes the cell if necessary.\n\t * @param {Number} index\n\t * @returns {Cell}\n\t */\n\tself.getCell = function (index) {\n\t\tlet cell = self.unsolved.get(index);\n\t\tif (cell !== undefined) {\n\t\t\treturn cell;\n\t\t}\n\t\tcell = new Cell(self.grid, index, self.tiles[index]);\n\t\tself.unsolved.set(index, cell);\n\t\tself.doLocalDeductions(index, cell);\n\t\treturn cell;\n\t};\n\n\t/**\n\t * Merges components between cell at index and its neighbour\n\t * @param {Number} index\n\t * @param {Number} neighbourIndex\n\t */\n\tself.mergeComponents = function (index, neighbourIndex) {\n\t\tconst component = self.components.get(index);\n\t\tif (component === undefined) {\n\t\t\tthrow 'Component to merge is undefined!';\n\t\t}\n\t\tconst neighbourComponent = self.components.get(neighbourIndex) || new Set([neighbourIndex]);\n\t\tif (component === neighbourComponent) {\n\t\t\tthrow new LoopDetectedException();\n\t\t}\n\t\tfor (let otherIndex of neighbourComponent) {\n\t\t\tself.components.set(otherIndex, component);\n\t\t\tcomponent.add(otherIndex);\n\t\t\t// loop avoidance logic\n\t\t\t// for every joining cell check if it has neighbours already in component\n\t\t\t// and add a wall between them in this case\n\t\t\tconst cell = self.getCell(otherIndex);\n\t\t\tconst occupiedDirections = cell.walls + cell.connections;\n\t\t\tlet forbidden = 0;\n\t\t\tfor (let direction of self.grid.DIRECTIONS) {\n\t\t\t\tif ((occupiedDirections & direction) > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst nIndex = self.grid.find_neighbour(otherIndex, direction).neighbour;\n\t\t\t\tif (component.has(nIndex)) {\n\t\t\t\t\tforbidden += direction;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (forbidden > 0) {\n\t\t\t\tcell.mustHaveAllWalls(forbidden);\n\t\t\t\tself.dirty.add(otherIndex);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Checks if any orientations can be ruled out based on immediate neighbours\n\t * @param {Number} index\n\t * @param {Cell} cell - cell at index\n\t */\n\tself.doLocalDeductions = function (index, cell) {\n\t\tif (cell.possible.size === 1) {\n\t\t\t// either empty or fully connected, is solved right away\n\t\t\tself.dirty.add(index);\n\t\t\treturn;\n\t\t}\n\n\t\tconst tile = self.grid.tileTypes.get(cell.initial);\n\t\tconst possibleBefore = cell.possible.size;\n\n\t\t// collect neighbour tile types\n\t\t/** @type {Number[]} */\n\t\tconst neighbourTiles = [];\n\t\tconst full = grid.fullyConnected(index);\n\t\tlet walls = 0;\n\t\tlet invalidDirections = 0;\n\t\tfor (let direction of self.grid.DIRECTIONS) {\n\t\t\tif ((full & direction) === 0) {\n\t\t\t\t// invalid direction that should be disregarged\n\t\t\t\tneighbourTiles.push(self.UNSOLVED);\n\t\t\t\tinvalidDirections += direction;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst { neighbour, empty } = self.grid.find_neighbour(index, direction);\n\t\t\tif (empty) {\n\t\t\t\twalls += direction;\n\t\t\t}\n\t\t\tneighbourTiles.push(self.grid.tileTypes.get(self.tiles[neighbour]) || self.UNSOLVED);\n\t\t}\n\t\t// remove orientations that contradict outer walls\n\t\t// any grid\n\t\tif (walls > 0) {\n\t\t\tcell.addWall(walls);\n\t\t\tcell.mustHaveAllWalls(walls);\n\t\t}\n\t\tif (invalidDirections > 0) {\n\t\t\tcell.mustHaveAllWalls(invalidDirections);\n\t\t}\n\t\t// remove orientations that connect only deadends\n\t\t// any grid\n\t\tif (self.checkDeadendConnections) {\n\t\t\tlet deadendConnections = 0;\n\t\t\tfor (let [i, neighbourTile] of neighbourTiles.entries()) {\n\t\t\t\tif (neighbourTile === self.grid.T1) {\n\t\t\t\t\tdeadendConnections += self.grid.DIRECTIONS[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcell.mustHaveSomeWalls(deadendConnections);\n\t\t}\n\n\t\t// Hexagrid specific tricks\n\t\tif (self.grid instanceof HexaGrid) {\n\t\t\t// can't connect middle prongs to a sharp turns tile\n\t\t\tif ([self.grid.T4K, self.grid.T3w, self.grid.T5, self.grid.T4psi].some((x) => x === tile)) {\n\t\t\t\tfor (let [i, neighbourTile] of neighbourTiles.entries()) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t[self.grid.T4K, self.grid.T2v, self.grid.T3w, self.grid.T5, self.grid.T4X].some(\n\t\t\t\t\t\t\t(x) => x === neighbourTile\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst direction = self.grid.DIRECTIONS[i];\n\t\t\t\t\t\tconst forbidden =\n\t\t\t\t\t\t\tdirection + self.grid.rotate(direction, 1) + self.grid.rotate(direction, -1);\n\t\t\t\t\t\tcell.mustHaveSomeWalls(forbidden);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// must connect psi-likes when they are adjacent\n\t\t\tif ([self.grid.T4psi, self.grid.T4X, self.grid.T5, self.grid.T3Y].some((x) => x === tile)) {\n\t\t\t\tfor (let [i, neighbourTile] of neighbourTiles.entries()) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t[self.grid.T4psi, self.grid.T4X, self.grid.T5, self.grid.T3Y].some(\n\t\t\t\t\t\t\t(x) => x === neighbourTile\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst direction = self.grid.DIRECTIONS[i];\n\t\t\t\t\t\tcell.mustHaveAllConnections(direction);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// never make two adjacent walls next to a psi & co\n\t\t\tif ([self.grid.T4psi, self.grid.T4X, self.grid.T5, self.grid.T3Y].every((x) => x !== tile)) {\n\t\t\t\tfor (let [i, neighbourTile] of neighbourTiles.entries()) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t[self.grid.T4psi, self.grid.T4X, self.grid.T5, self.grid.T3Y].some(\n\t\t\t\t\t\t\t(x) => x === neighbourTile\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst direction = self.grid.DIRECTIONS[i];\n\t\t\t\t\t\tlet forbidden = 0;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t[self.grid.T1, self.grid.T2c, self.grid.T2I].some(\n\t\t\t\t\t\t\t\t(x) => x === neighbourTiles[(i + 1) % 6]\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tforbidden += self.grid.DIRECTIONS[(i + 1) % 6];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t[self.grid.T1, self.grid.T2c, self.grid.T2I].some(\n\t\t\t\t\t\t\t\t(x) => x === neighbourTiles[(i + 5) % 6]\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tforbidden += self.grid.DIRECTIONS[(i + 5) % 6];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (forbidden === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let orientation of cell.possible) {\n\t\t\t\t\t\t\tif ((orientation & forbidden) > 0 && (orientation & direction) === 0) {\n\t\t\t\t\t\t\t\tcell.possible.delete(orientation);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cell.possible.size < possibleBefore) {\n\t\t\t// deduced something...\n\t\t\tself.dirty.add(index);\n\t\t}\n\t};\n\n\t/**\n\t * Process new info on cells\n\t * Removes orientations that contradict known constraints\n\t * Creates new walls/connections if remaining orientations require them\n\t * @yields {Step} - info about the processed cell\n\t */\n\tself.processDirtyCells = function* () {\n\t\twhile (self.dirty.size > 0) {\n\t\t\t// get a dirty cell\n\t\t\tconst index = self.dirty.keys().next().value;\n\t\t\tconst cell = self.getCell(index);\n\t\t\tif (cell === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// console.log('start processing dirty cell at', index, [...self.dirty]);\n\t\t\t// console.log({\n\t\t\t// \twalls: cell.walls,\n\t\t\t// \tconnections: cell.connections,\n\t\t\t// \tpossible: [...cell.possible]\n\t\t\t// });\n\t\t\t// apply constraints to limit possible orientations\n\t\t\tconst { addedWalls, addedConnections } = cell.applyConstraints();\n\t\t\t// create a component for this tile if it got a connection\n\t\t\tif (addedConnections > 0 && !self.components.has(index)) {\n\t\t\t\tself.components.set(index, new Set([index]));\n\t\t\t}\n\t\t\t// add walls to walled off neighbours\n\t\t\tif (addedWalls > 0) {\n\t\t\t\tfor (let direction of self.grid.DIRECTIONS) {\n\t\t\t\t\tif ((direction & addedWalls) > 0) {\n\t\t\t\t\t\tconst { neighbour, empty } = self.grid.find_neighbour(index, direction);\n\t\t\t\t\t\tif (empty) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst neighbourCell = self.getCell(neighbour);\n\t\t\t\t\t\tneighbourCell.addWall(self.grid.OPPOSITE.get(direction) || 0);\n\t\t\t\t\t\t// console.log('add wall to', neighbour, 'in direction', direction);\n\t\t\t\t\t\tself.dirty.add(neighbour);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add connections to connected neighbours\n\t\t\tif (addedConnections > 0) {\n\t\t\t\tfor (let direction of self.grid.DIRECTIONS) {\n\t\t\t\t\tif ((direction & addedConnections) > 0) {\n\t\t\t\t\t\tconst { neighbour, empty } = self.grid.find_neighbour(index, direction);\n\t\t\t\t\t\tif (empty) {\n\t\t\t\t\t\t\tthrow 'Trying to connect to an empty neighbour!';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst neighbourCell = self.getCell(neighbour);\n\t\t\t\t\t\tneighbourCell.addConnection(self.grid.OPPOSITE.get(direction) || 0);\n\t\t\t\t\t\t// console.log('add connection to', neighbour, 'in direction', direction);\n\t\t\t\t\t\tself.mergeComponents(index, neighbour);\n\t\t\t\t\t\tself.dirty.add(neighbour);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// check if cell is solved\n\t\t\tconst orientation = cell.possible.keys().next().value;\n\t\t\tconst final = cell.possible.size === 1;\n\t\t\tif (final) {\n\t\t\t\t// remove solved cell from its component\n\t\t\t\tconst component = self.components.get(index);\n\t\t\t\tif (component !== undefined) {\n\t\t\t\t\tcomponent.delete(index);\n\t\t\t\t\tif (component.size === 0 && self.unsolved.size > 1) {\n\t\t\t\t\t\tthrow new IslandDetectedException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tself.solution[index] = orientation;\n\t\t\t\tself.unsolved.delete(index);\n\t\t\t\tself.components.delete(index);\n\t\t\t}\n\t\t\t// console.log({ index, orientation, final });\n\t\t\tyield { index, orientation, final };\n\t\t\tself.dirty.delete(index);\n\t\t}\n\t};\n\n\t/**\n\t * Makes a copy of the solver\n\t * @return {Solver}\n\t */\n\tself.clone = function () {\n\t\tconst clone = new Solver([], self.grid);\n\t\tclone.unsolved = new Map([]);\n\t\tself.unsolved.forEach((cell, index) => {\n\t\t\tclone.unsolved.set(index, cell.clone());\n\t\t});\n\t\tclone.components = new Map([]);\n\t\tself.components.forEach((component, index) => {\n\t\t\tconst newComponent = new Set(component);\n\t\t\tfor (let componentCell of newComponent) {\n\t\t\t\tif (clone.components.has(componentCell)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tclone.components.set(componentCell, newComponent);\n\t\t\t}\n\t\t});\n\t\tclone.solution = [...self.solution];\n\t\tclone.dirty = new Set();\n\t\treturn clone;\n\t};\n\n\t/**\n\t * Chooses a tile/orientation to try out.\n\t * Selects an orientation from a tile with the least number of options\n\t * @returns {Number[]} - [index, orientation]\n\t */\n\tself.makeAGuess = function () {\n\t\tlet minPossibleSize = Number.POSITIVE_INFINITY;\n\t\tlet guessIndex = -1;\n\t\tfor (let [index, cell] of self.unsolved.entries()) {\n\t\t\tif (cell.possible.size < minPossibleSize) {\n\t\t\t\tguessIndex = index;\n\t\t\t\tminPossibleSize = cell.possible.size;\n\t\t\t\tif (minPossibleSize == 2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst cell = self.unsolved.get(guessIndex);\n\t\tif (cell === undefined) {\n\t\t\tthrow 'Cell selected for guessing is undefined!';\n\t\t}\n\t\tconst orientation = cell.possible.keys().next().value;\n\t\tcell.possible = new Set([orientation]);\n\t\tself.dirty.add(guessIndex);\n\t\treturn [guessIndex, orientation];\n\t};\n\n\t/**\n\t * Solve the puzzle\n\t * @param {boolean} allSolutions = false, whether to find all solutions.\n\t * If false then stops as soon as the first one is found\n\t * @yields {{stage:{SolvingStage}, step:{Step}}}\n\t */\n\tself.solve = function* (allSolutions = false) {\n\t\tif (self.dirty.size === 0) {\n\t\t\tconst toInit = new Set();\n\t\t\t// process empty cells first, then the rest\n\t\t\tfor (let index = 0; index < grid.total; index++) {\n\t\t\t\tif (grid.emptyCells.has(index)) {\n\t\t\t\t\tself.dirty.add(index);\n\t\t\t\t} else {\n\t\t\t\t\ttoInit.add(index);\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (toInit.size > 0) {\n\t\t\t\tconst nextTile = toInit.values().next().value;\n\t\t\t\ttoInit.delete(nextTile);\n\t\t\t\tif (self.unsolved.has(nextTile)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tself.dirty.add(nextTile);\n\t\t\t\tfor (let step of self.processDirtyCells()) {\n\t\t\t\t\ttoInit.delete(step.index);\n\t\t\t\t\tif (step.orientation === 0) {\n\t\t\t\t\t\t// don't report processing empty cell as a step\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tyield { stage: 'initial', step };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** @type {{index: Number, guess: Number, solver:Solver}[]} */\n\t\tconst trials = [{ index: -1, guess: -1, solver: self }];\n\t\tlet iter = 0;\n\t\twhile (trials.length > 0) {\n\t\t\titer += 1;\n\t\t\t// if (iter > 100) {\n\t\t\t// \tbreak;\n\t\t\t// }\n\t\t\tconst lastTrial = trials[trials.length - 1];\n\t\t\tif (lastTrial === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst { index, guess, solver } = lastTrial;\n\t\t\ttry {\n\t\t\t\tlet stage = trials.length === 1 ? 'initial' : 'guess';\n\t\t\t\tstage = self.solutions.length === 0 ? stage : 'aftercheck';\n\t\t\t\tfor (let step of solver.processDirtyCells()) {\n\t\t\t\t\tyield { stage, step };\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// something went wrong, no solution here\n\t\t\t\tif (trials.length > 1) {\n\t\t\t\t\ttrials.pop();\n\t\t\t\t\tconst parent = trials[trials.length - 1].solver;\n\t\t\t\t\tconst cell = parent.unsolved.get(index);\n\t\t\t\t\tcell?.possible.delete(guess);\n\t\t\t\t\tparent.dirty.add(index);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (solver.unsolved.size == 0) {\n\t\t\t\t// got a solution\n\t\t\t\tself.solution = solver.solution;\n\t\t\t\tself.solutions.push([...solver.solution]);\n\t\t\t\tif (!allSolutions) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (trials.length > 1) {\n\t\t\t\t\ttrials.pop();\n\t\t\t\t\tconst parent = trials[trials.length - 1].solver;\n\t\t\t\t\tconst cell = parent.unsolved.get(index);\n\t\t\t\t\tcell?.possible.delete(guess);\n\t\t\t\t\tparent.dirty.add(index);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we have to make a guess\n\t\t\t\tconst clone = solver.clone();\n\t\t\t\tconst [index, orientation] = clone.makeAGuess();\n\t\t\t\ttrials.push({\n\t\t\t\t\tindex,\n\t\t\t\t\tguess: orientation,\n\t\t\t\t\tsolver: clone\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Solve the puzzle but mark ambiguous areas with a special value\n\t * Does not yield steps\n\t * If the solution is unique then marked == solution\n\t * @returns {{\n\t * \tmarked: Number[],\n\t *  solvable: boolean,\n\t * \tunique: boolean,\n\t * }} - marked tiles, whether a puzzle is solvable, whether the solution is unique,\n\t */\n\tself.markAmbiguousTiles = function () {\n\t\tlet marked = [...self.solution];\n\t\tlet unique = true;\n\t\t// process what we can for a start\n\t\ttry {\n\t\t\tif (self.dirty.size === 0) {\n\t\t\t\t// process empty cells first, then the rest\n\t\t\t\tconst toInit = new Set();\n\t\t\t\tfor (let index = 0; index < grid.total; index++) {\n\t\t\t\t\tif (grid.emptyCells.has(index)) {\n\t\t\t\t\t\tself.dirty.add(index);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoInit.add(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (toInit.size > 0) {\n\t\t\t\t\tconst nextTile = toInit.values().next().value;\n\t\t\t\t\ttoInit.delete(nextTile);\n\t\t\t\t\tif (self.unsolved.has(nextTile)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tself.dirty.add(nextTile);\n\t\t\t\t\tfor (let step of self.processDirtyCells()) {\n\t\t\t\t\t\ttoInit.delete(step.index);\n\t\t\t\t\t\tif (step.final) {\n\t\t\t\t\t\t\tmarked[step.index] = step.orientation;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\treturn { marked, solvable: false, unique: false };\n\t\t}\n\t\t// console.log('done initial deductions, unsolved size', self.unsolved.size);\n\t\t// console.log(solution);\n\t\t/** @type {{index: Number, guess: Number, solver:Solver}[]} */\n\t\tconst trials = [{ index: -1, guess: -1, solver: self }];\n\t\tlet iter = 0;\n\t\twhile (trials.length > 0) {\n\t\t\titer += 1;\n\t\t\t// console.log('starting iter', iter);\n\t\t\t// if (iter > 100) {\n\t\t\t// \tbreak;\n\t\t\t// }\n\t\t\tconst lastTrial = trials[trials.length - 1];\n\t\t\tif (lastTrial === undefined) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst { index, guess, solver } = lastTrial;\n\t\t\t// console.log('unsolved at start', new Map(solver.unsolved.entries()));\n\t\t\ttry {\n\t\t\t\tfor (let _ of solver.processDirtyCells()) {\n\t\t\t\t}\n\t\t\t\t// console.log('unsolved after cleanup', new Map(solver.unsolved.entries()));\n\t\t\t} catch (error) {\n\t\t\t\t// console.log('smth went wrong', error);\n\t\t\t\t// something went wrong, no solution here\n\t\t\t\tif (trials.length > 1) {\n\t\t\t\t\t// console.log('error, destroying this trial');\n\t\t\t\t\ttrials.pop();\n\t\t\t\t\tconst parent = trials[trials.length - 1].solver;\n\t\t\t\t\tconst cell = parent.unsolved.get(index);\n\t\t\t\t\tcell?.possible.delete(guess);\n\t\t\t\t\tparent.dirty.add(index);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t// console.log('this was the last trial, exit loop');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (solver.unsolved.size == 0) {\n\t\t\t\t// got a solution\n\t\t\t\t// console.log('got a solution');\n\t\t\t\tfor (let i = 0; i < marked.length; i++) {\n\t\t\t\t\tif (marked[i] === self.UNSOLVED) {\n\t\t\t\t\t\tmarked[i] = solver.solution[i];\n\t\t\t\t\t} else if (marked[i] === self.AMBIGUOUS) {\n\t\t\t\t\t\t// do nothing\n\t\t\t\t\t} else if (marked[i] !== solver.solution[i]) {\n\t\t\t\t\t\t// console.log('ambiguous tile', i);\n\t\t\t\t\t\tmarked[i] = self.AMBIGUOUS;\n\t\t\t\t\t\tunique = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (trials.length > 1) {\n\t\t\t\t\t// console.log('checking other option to', index, guess);\n\t\t\t\t\ttrials.pop();\n\t\t\t\t\tconst parent = trials[trials.length - 1].solver;\n\t\t\t\t\tconst cell = parent.unsolved.get(index);\n\t\t\t\t\tcell?.possible.delete(guess);\n\t\t\t\t\tparent.dirty.add(index);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// we have to make a guess\n\t\t\t\tconst clone = solver.clone();\n\n\t\t\t\t// copypasta of makeAGuess function\n\t\t\t\t// because I want to ignore ambiguous tiles as guess candidates\n\t\t\t\tlet minPossibleSize = Number.POSITIVE_INFINITY;\n\t\t\t\tlet guessIndex = -1;\n\t\t\t\tfor (let [index, cell] of clone.unsolved.entries()) {\n\t\t\t\t\tif (marked[index] === self.AMBIGUOUS) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (cell.possible.size < minPossibleSize) {\n\t\t\t\t\t\tguessIndex = index;\n\t\t\t\t\t\tminPossibleSize = cell.possible.size;\n\t\t\t\t\t\tif (minPossibleSize == 2) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst cell = clone.unsolved.get(guessIndex);\n\t\t\t\tif (cell === undefined) {\n\t\t\t\t\t// console.log('can not guess because only ambiguous tiles are left');\n\t\t\t\t\tsolver.unsolved = new Map();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst orientation = cell.possible.keys().next().value;\n\t\t\t\tcell.possible = new Set([orientation]);\n\t\t\t\tclone.dirty.add(guessIndex);\n\n\t\t\t\t// console.log('making a guess', guessIndex, orientation);\n\t\t\t\ttrials.push({\n\t\t\t\t\tindex: guessIndex,\n\t\t\t\t\tguess: orientation,\n\t\t\t\t\tsolver: clone\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tconst solvable = marked.every((tile) => tile !== self.UNSOLVED);\n\t\treturn { marked, solvable, unique };\n\t};\n}\n","<script>\n\timport { controls } from './controls';\n\timport Tile from './Tile.svelte';\n\timport { onMount, onDestroy, createEventDispatcher, tick } from 'svelte';\n\timport { PipesGame } from './game';\n\timport { Solver } from './solver';\n\n\texport let grid;\n\texport let tiles = [];\n\texport let savedProgress = undefined;\n\texport let animate = false;\n\n\tlet game = new PipesGame(grid, tiles, savedProgress);\n\tlet solved = game.solved;\n\n\tlet innerWidth = 500;\n\tlet innerHeight = 500;\n\tconst pxPerCell = 50;\n\n\tconst viewBox = game.viewBox;\n\t$viewBox.width = Math.min(grid.XMAX - grid.XMIN, innerWidth / pxPerCell);\n\t$viewBox.height = Math.min(grid.YMAX - grid.YMIN, innerHeight / pxPerCell);\n\tconst visibleTiles = viewBox.visibleTiles;\n\n\tonMount(() => {\n\t\tgame.initializeBoard();\n\t});\n\n\twindow.autoSolve = async function() {\n\t\tlet solver;\n\t\tfunction sleep(ms = -1) {\n\t\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t\t}\n\t\tif (!$solved) {\n\t\t\t// unlock all tiles\n\t\t\tfor (let tileState of game.tileStates) {\n\t\t\t\tif (tileState.data.locked) {\n\t\t\t\t\ttileState.toggleLocked();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolver = new Solver(tiles, grid);\n\t\t\ttry {\n\t\t\t\tfor (let { stage, step } of solver.solve(true)) {\n\t\t\t\t\tif (stage === 'aftercheck') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tgame.toggleLocked(step.index, false);\n\t\t\t\t\tconst shouldLock = step.final && stage === 'initial';\n\t\t\t\t\tgame.setTileOrientation(step.index, step.orientation, !shouldLock);\n\t\t\t\t\tif (shouldLock) {\n\t\t\t\t\t\tgame.toggleLocked(step.index, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (animate) {\n\t\t\t\t\t\tawait sleep(200);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (solver.solutions.length > 1) {\n\t\t\t\t\t// unlock tiles that are different between solutions\n\t\t\t\t\t// and lock those that are the same\n\t\t\t\t\tgame.solved.set(false);\n\t\t\t\t\tgame._solved = false;\n\t\t\t\t\tfor (let [i, tile] of solver.solutions[0].entries()) {\n\t\t\t\t\t\tconst isSame = solver.solutions.every((solution) => solution[i] === tile);\n\t\t\t\t\t\tif (game.tileStates[i].data.locked !== isSame) {\n\t\t\t\t\t\t\tgame.tileStates[i].toggleLocked();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(error);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\treturn new Promise(resolve=>{\n\t\t\t\tresolve()\n\t\t\t})\n\t\t}\n\t}\n\t$: if ($solved) {\n\t\tconsole.log('\"window.onPuzzleSovled()\" has been called' )\n\t\twindow.onPuzzleSolved()\n\t}\n</script>\n<div class=\"puzzle animation-normal\" class:solved={$solved}>\n\t<svg\n\t\twidth=490\n\t\theight=490\n\t\tviewBox=\"{$viewBox.xmin} {$viewBox.ymin} {$viewBox.width} {$viewBox.height}\"\n\t\tuse:controls={game}\n\t\ton:contextmenu|preventDefault={() => {}}\n\t>\n\t\t{#each $visibleTiles as visibleTile, i (visibleTile.key)}\n\t\t\t<Tile\n\t\t\t\ti={visibleTile.index}\n\t\t\t\t{game}\n\t\t\t\tcx={visibleTile.x}\n\t\t\t\tcy={visibleTile.y}\n\t\t\t/>\n\t\t{/each}\n\t</svg>\n</div>\n\n<style>\n\tsvg {\n\t\tdisplay: block;\n      border: 2px solid red;\n\t\t\t/*background: black;*/\n      /*background: aqua;*/\n\t}\n\t/* win animation */\n\t.solved :global(.inside) {\n\t\tfilter: hue-rotate(360deg);\n\t\ttransition: filter 2s;\n\t}\n</style>\n","import { RegularPolygonTile } from './polygonutils';\n\nconst EAST = 1;\nconst NORTH = 2;\nconst WEST = 4;\nconst SOUTH = 8;\n\nconst SQUARE = new RegularPolygonTile(4, 0, 0.5);\n\nexport class SquareGrid {\n\tDIRECTIONS = [EAST, NORTH, WEST, SOUTH];\n\tEDGEMARK_DIRECTIONS = [NORTH, WEST];\n\tOPPOSITE = new Map([\n\t\t[NORTH, SOUTH],\n\t\t[SOUTH, NORTH],\n\t\t[EAST, WEST],\n\t\t[WEST, EAST]\n\t]);\n\tXY_DELTAS = new Map([\n\t\t[NORTH, [0, 1]],\n\t\t[SOUTH, [0, -1]],\n\t\t[EAST, [1, 0]],\n\t\t[WEST, [-1, 0]]\n\t]);\n\tNUM_DIRECTIONS = 4;\n\tKIND = 'square';\n\tPIPE_WIDTH = 0.15;\n\tSTROKE_WIDTH = 0.06;\n\tPIPE_LENGTH = 0.5;\n\tSINK_RADIUS = 0.2;\n\n\t/** @type {Set<Number>} - indices of empty cells */\n\temptyCells;\n\t/** @type {Number} - total number of cells including empties */\n\ttotal;\n\n\t/**\n\t *\n\t * @param {Number} width\n\t * @param {Number} height\n\t * @param {Boolean} wrap\n\t * @param {Number[]} tiles\n\t */\n\tconstructor(width, height, wrap, tiles = []) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.wrap = wrap;\n\n\t\tthis.emptyCells = new Set();\n\t\ttiles.forEach((tile, index) => {\n\t\t\tif (tile === 0) {\n\t\t\t\tthis.emptyCells.add(index);\n\t\t\t}\n\t\t});\n\t\tthis.total = width * height;\n\n\t\tthis.XMIN = -0.6 - (wrap ? 1 : 0);\n\t\tthis.XMAX = width - 0.4 + (wrap ? 1 : 0);\n\t\tthis.YMIN = -(1 + (wrap ? 1 : 0));\n\t\tthis.YMAX = height + (wrap ? 1 : 0);\n\n\t\t/* Tile types for use in solver */\n\t\tthis.T0 = 0;\n\t\tthis.T1 = 1;\n\t\tthis.T2L = 3;\n\t\tthis.T2I = 5;\n\t\tthis.T3 = 7;\n\t\t/** @type {Map<Number,Number>} */\n\t\tthis.tileTypes = new Map();\n\t\tfor (let t = 0; t < 16; t++) {\n\t\t\tlet rotated = t;\n\t\t\twhile (!this.tileTypes.has(rotated)) {\n\t\t\t\tthis.tileTypes.set(rotated, t);\n\t\t\t\trotated = this.rotate(rotated, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Number} index\n\t */\n\tindex_to_xy(index) {\n\t\tconst x = index % this.width;\n\t\tconst y = Math.round((index - x) / this.width);\n\t\treturn [x, y];\n\t}\n\n\t/**\n\t * Determines which tile a point at (x, y) belongs to\n\t * Returns tile index and tile center coordinates\n\t * If the point is over empty space then tileIndex is -1\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @returns {{index: Number, x:Number, y: Number}}\n\t */\n\twhich_tile_at(x, y) {\n\t\tconst x0 = Math.round(x);\n\t\tconst y0 = Math.round(y);\n\t\tlet index = this.rc_to_index(y0, x0);\n\t\tif (this.emptyCells.has(index)) {\n\t\t\tindex = -1;\n\t\t}\n\t\treturn { index, x: x0, y: y0 };\n\t}\n\n\t/**\n\t * @param {Number} index\n\t * @param {Number} direction\n\t * @returns {{neighbour: Number, empty: boolean}} - neighbour index, is the neighbour an empty cell or outside the board\n\t */\n\tfind_neighbour(index, direction) {\n\t\tlet c = index % this.width;\n\t\tlet r = (index - c) / this.width;\n\t\tlet neighbour = -1;\n\n\t\tconst [dc, dr] = this.XY_DELTAS.get(direction) || [0, 0];\n\t\tr -= dr;\n\t\tc += dc;\n\t\tneighbour = this.rc_to_index(r, c);\n\t\tconst empty = neighbour === -1 || this.emptyCells.has(neighbour);\n\t\treturn { neighbour, empty };\n\t}\n\n\t/**\n\t * Get index of tile located at row r column c\n\t * @param {Number} r\n\t * @param {Number} c\n\t * @returns {Number}\n\t */\n\trc_to_index(r, c) {\n\t\tif (this.wrap) {\n\t\t\tr = r % this.height;\n\t\t\tif (r < 0) {\n\t\t\t\tr += this.height;\n\t\t\t}\n\t\t\tc = c % this.width;\n\t\t\tif (c < 0) {\n\t\t\t\tc += this.width;\n\t\t\t}\n\t\t} else {\n\t\t\tif (r < 0 || r >= this.height) {\n\t\t\t\treturn -1;\n\t\t\t} else if (c < 0 || c >= this.width) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn this.width * r + c;\n\t}\n\n\t/**\n\t * Makes cell at index empty\n\t * @param {Number} index\n\t */\n\tmakeEmpty(index) {\n\t\tthis.emptyCells.add(index);\n\t}\n\n\t/**\n\t * A number corresponding to fully connected tile\n\t * @param {Number} index\n\t * @returns {Number}\n\t */\n\tfullyConnected(index) {\n\t\treturn 15;\n\t}\n\n\t/**\n\t * Compute tile orientation after a number of rotations\n\t * @param {Number} tile\n\t * @param {Number} rotations\n\t * @param {Number} index - index of tile, not used here\n\t * @returns\n\t */\n\trotate(tile, rotations, index = 0) {\n\t\treturn SQUARE.rotate(tile, rotations);\n\t}\n\n\t/**\n\t * Get angle for displaying rotated pipes state\n\t * @param {Number} rotations\n\t * @param {Number} index\n\t * @returns\n\t */\n\tgetAngle(rotations, index) {\n\t\treturn SQUARE.get_angle(rotations);\n\t}\n\n\t/**\n\t *\n\t * @param {Number} tile\n\t * @param {Number} rotations\n\t * @returns {Number[]}\n\t */\n\tgetDirections(tile, rotations = 0) {\n\t\treturn SQUARE.get_directions(tile, rotations);\n\t}\n\n\t/**\n\t * @param {import('$lib/puzzle/viewbox').ViewBox} box\n\t * @returns {import('$lib/puzzle/viewbox').VisibleTile[]}\n\t */\n\tgetVisibleTiles(box) {\n\t\tlet rmin = Math.floor(box.ymin) - 1;\n\t\tlet rmax = Math.ceil(box.ymin + box.height) + 1;\n\t\tif (!this.wrap) {\n\t\t\trmin = Math.max(0, rmin);\n\t\t\trmax = Math.min(this.height - 1, rmax);\n\t\t}\n\t\tlet cmin = Math.floor(box.xmin) - 1;\n\t\tlet cmax = Math.ceil(box.xmin + box.width) + 1;\n\t\tif (!this.wrap) {\n\t\t\tcmin = Math.max(0, cmin);\n\t\t\tcmax = Math.min(this.width - 1, cmax);\n\t\t}\n\t\tconst visibleTiles = [];\n\t\tfor (let r = rmin; r <= rmax; r++) {\n\t\t\tfor (let c = cmin; c <= cmax; c++) {\n\t\t\t\tconst index = this.rc_to_index(r, c);\n\t\t\t\tif (index === -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst x = c;\n\t\t\t\tconst y = r;\n\t\t\t\tconst key = `${Math.round(x)}_${Math.round(y)}`;\n\t\t\t\tvisibleTiles.push({\n\t\t\t\t\tindex,\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\tkey\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn visibleTiles;\n\t}\n\n\t/**\n\t * Tile contour path for svg drawing\n\t * @param {Number} index\n\t * @returns\n\t */\n\tgetTilePath(index) {\n\t\treturn SQUARE.contour_path;\n\t}\n\n\t/**\n\t * Pipes lines path\n\t * @param {Number} tile\n\t * @param {Number} index\n\t */\n\tgetPipesPath(tile, index) {\n\t\treturn SQUARE.get_pipes_path(tile);\n\t}\n\n\t/**\n\t * Computes position for drawing the tile guiding dot\n\t * @param {Number} tile\n\t * * @param {Number} index\n\t * @returns {Number[]}\n\t */\n\tgetGuideDotPosition(tile, index) {\n\t\tconst [dx, dy] = SQUARE.get_guide_dot_position(tile);\n\t\treturn [0.8 * dx, 0.8 * dy];\n\t}\n\t/**\n\t * Compute number of rotations for orienting a tile with \"click to orient\" control mode\n\t * @param {Number} tile\n\t * @param {Number} old_rotations\n\t * @param {Number} new_angle\n\t * @param {Number} index\n\t */\n\tclickOrientTile(tile, old_rotations, new_angle, index = 0) {\n\t\treturn SQUARE.click_orient_tile(tile, old_rotations, new_angle);\n\t}\n\t/**\n\t * Returns coordinates of endpoints of edgemark line\n\t * @param {Number} direction\n\t * @param {Number} index\n\t * @returns\n\t */\n\tgetEdgemarkLine(direction, index = 0) {\n\t\treturn SQUARE.get_edgemark_line(direction);\n\t}\n\n\t/**\n\t * Check if a drag gesture resembles drawing an edge mark\n\t * @param {Number} tile_index\n\t * @param {Number} tile_x\n\t * @param {Number} tile_y\n\t * @param {Number} x1\n\t * @param {Number} x2\n\t * @param {Number} y1\n\t * @param {Number} y2\n\t */\n\tdetectEdgemarkGesture(tile_index, tile_x, tile_y, x1, x2, y1, y2) {\n\t\treturn SQUARE.detect_edgemark_gesture(x1 - tile_x, x2 - tile_x, tile_y - y1, tile_y - y2);\n\t}\n\n\t/**\n\t * Tells if a point is close to one of tile's edges\n\t * @param {import('$lib/puzzle/controls').PointerOrigin} point\n\t */\n\twhichEdge(point) {\n\t\tconst { x, y, tileX, tileY } = point;\n\t\tconst dx = x - tileX;\n\t\tconst dy = tileY - y;\n\t\treturn SQUARE.is_close_to_edge(dx, dy);\n\t}\n}\n","import { RegularPolygonTile } from './polygonutils';\n\nconst EAST = 1;\nconst NORTHEAST = 2;\nconst NORTH = 4;\nconst NORTHWEST = 8;\nconst WEST = 16;\nconst SOUTHWEST = 32;\nconst SOUTH = 64;\nconst SOUTHEAST = 128;\n\nconst Roct = 0.5;\nconst R0 = 0.49;\nconst d = Roct * Math.sin(Math.PI / 8);\nconst d0 = R0 * Math.sin(Math.PI / 8);\nconst Rsq = ((Roct - d) * Math.SQRT2) / 2;\nconst OCTAGON = new RegularPolygonTile(8, 0, 0.5);\nconst SQUARE = new RegularPolygonTile(4, Math.PI / 4, Rsq, [2, 8, 32, 128]);\n\nexport class OctaGrid {\n\tDIRECTIONS = [EAST, NORTHEAST, NORTH, NORTHWEST, WEST, SOUTHWEST, SOUTH, SOUTHEAST];\n\tEDGEMARK_DIRECTIONS = [NORTHEAST, NORTH, NORTHWEST, WEST];\n\tOPPOSITE = new Map([\n\t\t[NORTH, SOUTH],\n\t\t[SOUTH, NORTH],\n\t\t[EAST, WEST],\n\t\t[WEST, EAST],\n\t\t[NORTHEAST, SOUTHWEST],\n\t\t[SOUTHWEST, NORTHEAST],\n\t\t[NORTHWEST, SOUTHEAST],\n\t\t[SOUTHEAST, NORTHWEST]\n\t]);\n\tRC_DELTAS = new Map([\n\t\t[EAST, [1, 0]],\n\t\t[NORTHEAST, [0.5, 0.5]],\n\t\t[NORTH, [0, 1]],\n\t\t[NORTHWEST, [-0.5, 0.5]],\n\t\t[WEST, [-1, 0]],\n\t\t[SOUTHWEST, [-0.5, -0.5]],\n\t\t[SOUTH, [0, -1]],\n\t\t[SOUTHEAST, [0.5, -0.5]]\n\t]);\n\tXY_DELTAS = new Map([\n\t\t[EAST, [1, 0]],\n\t\t[NORTHEAST, [Math.SQRT1_2, Math.SQRT1_2]],\n\t\t[NORTH, [0, 1]],\n\t\t[NORTHWEST, [-Math.SQRT1_2, Math.SQRT1_2]],\n\t\t[WEST, [-1, 0]],\n\t\t[SOUTHWEST, [-Math.SQRT1_2, -Math.SQRT1_2]],\n\t\t[SOUTH, [0, -1]],\n\t\t[SOUTHEAST, [Math.SQRT1_2, -Math.SQRT1_2]]\n\t]);\n\tANGLE_DEG = 45;\n\tANGLE_RAD = Math.PI / 4;\n\tNUM_DIRECTIONS = 8;\n\tKIND = 'octagonal';\n\tPIPE_WIDTH = 0.1;\n\tSTROKE_WIDTH = 0.04;\n\tPIPE_LENGTH = 0.5;\n\tSINK_RADIUS = 0.13;\n\n\t/** @type {Set<Number>} - indices of empty cells */\n\temptyCells;\n\t/** @type {Number} - total number of cells excluding empties */\n\ttotal;\n\n\t/**\n\t *\n\t * @param {Number} width\n\t * @param {Number} height\n\t * @param {Boolean} wrap\n\t * @param {Number[]} tiles\n\t */\n\tconstructor(width, height, wrap, tiles = []) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.wrap = wrap;\n\n\t\tthis.emptyCells = new Set();\n\t\ttiles.forEach((tile, index) => {\n\t\t\tif (tile === 0) {\n\t\t\t\tthis.emptyCells.add(index);\n\t\t\t}\n\t\t});\n\t\tif (tiles.length === 0 && !wrap) {\n\t\t\tconst N = 2 * width * height;\n\t\t\tfor (let w = 1; w <= width; w++) {\n\t\t\t\tthis.emptyCells.add(N - w);\n\t\t\t}\n\t\t\tfor (let h = 1; h < height; h++) {\n\t\t\t\tthis.emptyCells.add(N - 1 - width * h);\n\t\t\t}\n\t\t}\n\t\tthis.total = 2 * width * height;\n\n\t\tthis.XMIN = -0.6 - (wrap ? 1 : 0);\n\t\tthis.XMAX = width - 0.4 + (wrap ? 1 : 0);\n\t\tthis.YMIN = -(1 + (wrap ? 1 : 0));\n\t\tthis.YMAX = height + (wrap ? 1 : 0);\n\n\t\t/* Tile types for use in solver */\n\t\tthis.T0 = 0;\n\t\tthis.T1 = 1;\n\t\tthis.T2v = 3;\n\t\tthis.T2L = 5;\n\t\tthis.T2C = 9;\n\t\tthis.T2I = 17;\n\t\tthis.T3w = 7;\n\t\t/** @type {Map<Number,Number>} */\n\t\tthis.tileTypes = new Map();\n\t\tfor (let t = 0; t < 256; t++) {\n\t\t\tlet rotated = t;\n\t\t\twhile (!this.tileTypes.has(rotated)) {\n\t\t\t\tthis.tileTypes.set(rotated, t);\n\t\t\t\trotated = this.rotate(rotated, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Number} index\n\t */\n\tindex_to_xy(index) {\n\t\tconst isSquare = index >= this.width * this.height;\n\t\tconst i = index - (isSquare ? this.width * this.height : 0);\n\t\tconst x = i % this.width;\n\t\tconst y = Math.round((i - x) / this.width);\n\t\treturn [x + (isSquare ? 0.5 : 0), y + (isSquare ? 0.5 : 0)];\n\t}\n\n\t/**\n\t * Determines which tile a point at (x, y) belongs to\n\t * Returns tile index and tile center coordinates\n\t * If the point is over empty space then tileIndex is -1\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @returns {{index: Number, x:Number, y: Number}}\n\t */\n\twhich_tile_at(x, y) {\n\t\tconst x1 = Math.floor(x);\n\t\tconst x2 = Math.ceil(x);\n\t\tconst xm = (x1 + x2) * 0.5;\n\t\tconst x0 = Math.round(x);\n\n\t\tconst y1 = Math.floor(y);\n\t\tconst y2 = Math.ceil(y);\n\t\tconst ym = (y1 + y2) * 0.5;\n\t\tconst y0 = Math.round(y);\n\n\t\tconst r = 0.5 * (1 - Math.sin(Math.PI / 8));\n\t\tif (Math.abs(x - xm) + Math.abs(y - ym) <= r) {\n\t\t\t// square tile\n\t\t\tlet index = this.rc_to_index(ym, xm);\n\t\t\tif (this.emptyCells.has(index)) {\n\t\t\t\tindex = -1;\n\t\t\t}\n\t\t\treturn { index, x: xm, y: ym };\n\t\t}\n\t\t// octagon tile\n\t\tlet index = this.rc_to_index(y0, x0);\n\t\tif (this.emptyCells.has(index)) {\n\t\t\tindex = -1;\n\t\t}\n\t\treturn { index, x: x0, y: y0 };\n\t}\n\n\t/**\n\t * @param {Number} index\n\t * @param {Number} direction\n\t * @returns {{neighbour: Number, empty: boolean}} - neighbour index, is the neighbour an empty cell or outside the board\n\t */\n\tfind_neighbour(index, direction) {\n\t\tlet c = 0;\n\t\tlet r = 0;\n\t\tif (index >= this.width * this.height) {\n\t\t\t// square cell\n\t\t\tif ([NORTH, SOUTH, EAST, WEST].some((d) => d === direction)) {\n\t\t\t\treturn { neighbour: -1, empty: true };\n\t\t\t}\n\t\t\tindex -= this.width * this.height;\n\t\t\tc += 0.5;\n\t\t\tr += 0.5;\n\t\t}\n\t\tc += index % this.width;\n\t\tr += (index - (index % this.width)) / this.width;\n\t\tlet neighbour = -1;\n\n\t\tconst [dc, dr] = this.RC_DELTAS.get(direction) || [0, 0];\n\t\tr -= dr;\n\t\tc += dc;\n\t\tneighbour = this.rc_to_index(r, c);\n\t\tconst empty = neighbour === -1 || this.emptyCells.has(neighbour);\n\t\treturn { neighbour, empty };\n\t}\n\n\t/**\n\t * Get index of tile located at row r column c\n\t * @param {Number} r\n\t * @param {Number} c\n\t * @returns {Number}\n\t */\n\trc_to_index(r, c) {\n\t\tlet squareIndexOffset = 0;\n\t\tif (r - Math.floor(r) > 0.2) {\n\t\t\tsquareIndexOffset = this.width * this.height;\n\t\t\tr = Math.floor(r);\n\t\t\tc = Math.floor(c);\n\t\t}\n\t\tif (this.wrap) {\n\t\t\tr = r % this.height;\n\t\t\tif (r < 0) {\n\t\t\t\tr += this.height;\n\t\t\t}\n\t\t\tc = c % this.width;\n\t\t\tif (c < 0) {\n\t\t\t\tc += this.width;\n\t\t\t}\n\t\t} else {\n\t\t\tif (r < 0 || r >= this.height) {\n\t\t\t\treturn -1;\n\t\t\t} else if (c < 0 || c >= this.width) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn this.width * r + c + squareIndexOffset;\n\t}\n\n\t/**\n\t * Makes cell at index empty\n\t * @param {Number} index\n\t */\n\tmakeEmpty(index) {\n\t\tthis.emptyCells.add(index);\n\t}\n\n\t/**\n\t * @param {import('$lib/puzzle/viewbox').ViewBox} box\n\t * @returns {import('$lib/puzzle/viewbox').VisibleTile[]}\n\t */\n\tgetVisibleTiles(box) {\n\t\tlet rmin = Math.floor(box.ymin) - 1;\n\t\tlet rmax = Math.ceil(box.ymin + box.height) + 1;\n\t\tif (!this.wrap) {\n\t\t\trmin = Math.max(0, rmin);\n\t\t\trmax = Math.min(this.height - 1, rmax);\n\t\t}\n\t\tlet cmin = Math.floor(box.xmin) - 1;\n\t\tlet cmax = Math.ceil(box.xmin + box.width) + 1;\n\t\tif (!this.wrap) {\n\t\t\tcmin = Math.max(0, cmin);\n\t\t\tcmax = Math.min(this.width - 1, cmax);\n\t\t}\n\t\tconst visibleTiles = [];\n\t\tfor (let r = rmin; r <= rmax; r++) {\n\t\t\t// add octagons row\n\t\t\tfor (let c = cmin; c <= cmax; c++) {\n\t\t\t\tconst indexOct = this.rc_to_index(r, c);\n\t\t\t\tif (indexOct !== -1 && !this.emptyCells.has(indexOct)) {\n\t\t\t\t\tconst x = c;\n\t\t\t\t\tconst y = r;\n\t\t\t\t\tconst key = `${Math.round(2 * x)}_${Math.round(2 * y)}`;\n\t\t\t\t\tvisibleTiles.push({\n\t\t\t\t\t\tindex: indexOct,\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\tkey\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add squares row\n\t\t\t// this ordering ensures edgemarks are visible and not overlapped by other tiles\n\t\t\tconst rs = r + 0.5;\n\t\t\tfor (let c = cmin; c <= cmax; c++) {\n\t\t\t\tconst cs = c + 0.5;\n\t\t\t\tconst indexSquare = this.rc_to_index(rs, cs);\n\t\t\t\tif (indexSquare !== -1 && !this.emptyCells.has(indexSquare)) {\n\t\t\t\t\tconst x = cs;\n\t\t\t\t\tconst y = rs;\n\t\t\t\t\tconst key = `${Math.round(2 * x)}_${Math.round(2 * y)}`;\n\t\t\t\t\tvisibleTiles.push({\n\t\t\t\t\t\tindex: indexSquare,\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\tkey\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn visibleTiles;\n\t}\n\n\t/**\n\t * @param {Number} index\n\t * @returns {RegularPolygonTile}\n\t */\n\t#tile_at(index) {\n\t\tif (index >= this.width * this.height) {\n\t\t\treturn SQUARE;\n\t\t}\n\t\treturn OCTAGON;\n\t}\n\n\t/**\n\t * A number corresponding to fully connected tile\n\t * @param {Number} index\n\t * @returns {Number}\n\t */\n\tfullyConnected(index) {\n\t\treturn this.#tile_at(index).fully_connected;\n\t}\n\n\t/**\n\t * Compute tile orientation after a number of rotations\n\t * @param {Number} tile\n\t * @param {Number} rotations\n\t * @param {Number} index - index of tile, not used here\n\t * @returns\n\t */\n\trotate(tile, rotations, index = 0) {\n\t\treturn this.#tile_at(index).rotate(tile, rotations);\n\t}\n\n\t/**\n\t * Get angle for displaying rotated pipes state\n\t * @param {Number} rotations\n\t * @param {Number} index\n\t * @returns\n\t */\n\tgetAngle(rotations, index) {\n\t\treturn this.#tile_at(index).get_angle(rotations);\n\t}\n\n\t/**\n\t *\n\t * @param {Number} tile\n\t * @param {Number} rotations\n\t * @param {Number} index\n\t * @returns {Number[]}\n\t */\n\tgetDirections(tile, rotations = 0, index) {\n\t\treturn this.#tile_at(index).get_directions(tile, rotations);\n\t}\n\n\t/**\n\t * Tile contour path for svg drawing\n\t * @param {Number} index\n\t * @returns\n\t */\n\tgetTilePath(index) {\n\t\treturn this.#tile_at(index).contour_path;\n\t}\n\n\t/**\n\t * Pipes lines path\n\t * @param {Number} tile\n\t * @param {Number} index\n\t */\n\tgetPipesPath(tile, index) {\n\t\treturn this.#tile_at(index).get_pipes_path(tile);\n\t}\n\n\t/**\n\t * Computes position for drawing the tile guiding dot\n\t * @param {Number} tile\n\t * @param {Number} index\n\t * * @returns {Number[]}\n\t */\n\tgetGuideDotPosition(tile, index = 0) {\n\t\tconst [dx, dy] = this.#tile_at(index).get_guide_dot_position(tile);\n\t\treturn [0.7 * dx, 0.7 * dy];\n\t}\n\n\t/**\n\t * Compute number of rotations for orienting a tile with \"click to orient\" control mode\n\t * @param {Number} tile\n\t * @param {Number} old_rotations\n\t * @param {Number} new_angle\n\t * @param {Number} index\n\t */\n\tclickOrientTile(tile, old_rotations, new_angle, index = 0) {\n\t\treturn this.#tile_at(index).click_orient_tile(tile, old_rotations, new_angle);\n\t}\n\n\t/**\n\t * Returns coordinates of endpoints of edgemark line\n\t * @param {Number} direction\n\t * @param {Number} index\n\t * @returns\n\t */\n\tgetEdgemarkLine(direction, index = 0) {\n\t\treturn this.#tile_at(index).get_edgemark_line(direction);\n\t}\n\n\t/**\n\t * Check if a drag gesture resembles drawing an edge mark\n\t * @param {Number} tile_index\n\t * @param {Number} tile_x\n\t * @param {Number} tile_y\n\t * @param {Number} x1\n\t * @param {Number} x2\n\t * @param {Number} y1\n\t * @param {Number} y2\n\t */\n\tdetectEdgemarkGesture(tile_index, tile_x, tile_y, x1, x2, y1, y2) {\n\t\treturn this.#tile_at(tile_index).detect_edgemark_gesture(\n\t\t\tx1 - tile_x,\n\t\t\tx2 - tile_x,\n\t\t\ttile_y - y1,\n\t\t\ttile_y - y2\n\t\t);\n\t}\n\n\t/**\n\t * Tells if a point is close to one of tile's edges\n\t * @param {import('$lib/puzzle/controls').PointerOrigin} point\n\t */\n\twhichEdge(point) {\n\t\tconst { x, y, tileX, tileY, tileIndex } = point;\n\t\tconst dx = x - tileX;\n\t\tconst dy = tileY - y;\n\t\treturn this.#tile_at(tileIndex).is_close_to_edge(dx, dy);\n\t}\n}\n","import { Cell, Solver } from './solver';\n\n/**\n * @typedef {'unique'|'multiple'|'whatever'} SolutionsNumber\n */\n\n/**\n * Returns a random element from an array\n * @param {Array<any>} array\n */\nfunction getRandomElement(array) {\n\tconst index = Math.floor(Math.random() * array.length);\n\treturn array[index];\n}\n\n/**\n * Randomize tile rotations\n * @param {Number[]} tiles\n * @param {import('$lib/puzzle/grids/grids').Grid} grid\n * @returns {Number[]}\n */\nfunction randomRotate(tiles, grid) {\n\tconst numDirections = grid.DIRECTIONS.length;\n\treturn tiles.map((tile, index) => {\n\t\tif (tile === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet rotated = grid.rotate(tile, Math.floor(Math.random() * numDirections), index);\n\t\treturn rotated;\n\t});\n}\n\nexport class Generator {\n\tconstructor(grid) {\n\t\tthis.grid = grid;\n\t}\n\n\t/**\n\t * Fills a grid with tiles using GrowingTree algorithm\n\t * At branchingAmount = 0 it's like recursive backtracking\n\t * At branchingAmount = 1 it's like Prim's algorithm\n\t * Intermediate values give some mix of these methods\n\t * @param {Number} branchingAmount - a number in range [0, 1], higher values lead to more branching splits\n\t * @param {Number} avoidObvious - number in range [0, 1], higher values lead to fewer obvious tiles along borders\n\t * @param {Number} avoidStraights - number in range [0, 1], higher values lead to fewer straight tiles\n\t * @param {Number[]} startTiles - starting point tiles if we're fixing ambiguities\n\t * @returns {Number[]} - unrandomized tiles array\n\t */\n\tpregenerate_growingtree(branchingAmount, avoidObvious = 0, avoidStraights = 0, startTiles = []) {\n\t\tconst total = this.grid.total;\n\n\t\t/** @type {Set<Number>} A set of unvisited nodes*/\n\t\tconst unvisited = new Set([...Array(total).keys()]);\n\t\tfor (let index of this.grid.emptyCells) {\n\t\t\tunvisited.delete(index);\n\t\t}\n\t\t/** @type {Number[]} A list of tile shapes */\n\t\tconst tiles = [];\n\t\tfor (let i = 0; i < total; i++) {\n\t\t\ttiles.push(0);\n\t\t}\n\t\t/** @type {Number[]} A list of visited nodes */\n\t\tconst visited = [];\n\t\t/** @type {Number[]} - visited tiles that will become obvious if used again */\n\t\tconst avoiding = [];\n\t\t/** @type {Number[]} - visited tiles that will become fully connected if used again */\n\t\tconst lastResortNodes = [];\n\n\t\t// reuse non-ambiguous portions of startTiles\n\t\tif (startTiles.length === total) {\n\t\t\tconst to_check = new Set(unvisited);\n\t\t\tconst components = [];\n\t\t\twhile (to_check.size > 0) {\n\t\t\t\tconst index = to_check.values().next().value;\n\t\t\t\tto_check.delete(index);\n\t\t\t\tif (startTiles[index] < 0) {\n\t\t\t\t\t// ambiguous tile, ignore it\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst to_visit = new Set([index]);\n\t\t\t\tconst component = new Set();\n\t\t\t\twhile (to_visit.size > 0) {\n\t\t\t\t\tconst i = to_visit.values().next().value;\n\t\t\t\t\tto_visit.delete(i);\n\t\t\t\t\tto_check.delete(i);\n\t\t\t\t\tcomponent.add(i);\n\t\t\t\t\tfor (let direction of this.grid.getDirections(startTiles[i], 0, i)) {\n\t\t\t\t\t\tconst { neighbour, empty } = this.grid.find_neighbour(i, direction);\n\t\t\t\t\t\tif (empty || startTiles[neighbour] < 0 || component.has(neighbour)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto_visit.add(neighbour);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcomponents.push(component);\n\t\t\t\tcomponents.sort((a, b) => -(a.size - b.size));\n\t\t\t\tif (components[0].size >= to_check.size) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// components[0] now has the largest region of non-ambiguous connected tiles\n\t\t\tfor (let index of components[0] || []) {\n\t\t\t\tfor (let direction of this.grid.getDirections(startTiles[index], 0, index)) {\n\t\t\t\t\tconst { neighbour } = this.grid.find_neighbour(index, direction);\n\t\t\t\t\tif (components[0].has(neighbour)) {\n\t\t\t\t\t\ttiles[index] += direction;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisited.push(index);\n\t\t\t\tunvisited.delete(index);\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Map<Number, Number>} tile index => tile walls */\n\t\tconst borders = new Map();\n\t\t/** @type {Map<Number, Set<Number>>} tile walls => set of forbidden types-orientations */\n\t\tconst forbidden = new Map();\n\t\tif (avoidObvious > 0) {\n\t\t\tfor (let tileIndex of unvisited) {\n\t\t\t\tfor (let direction of this.grid.DIRECTIONS) {\n\t\t\t\t\tconst { neighbour, empty } = this.grid.find_neighbour(tileIndex, direction);\n\t\t\t\t\tif (empty) {\n\t\t\t\t\t\tborders.set(tileIndex, (borders.get(tileIndex) || 0) + direction);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let walls of new Set(borders.values())) {\n\t\t\t\tlet cell = new Cell(this.grid, 0, -1);\n\t\t\t\tcell.addWall(walls);\n\t\t\t\tcell.applyConstraints();\n\t\t\t\t/** @type {Map<Number, Set<Number>>} */\n\t\t\t\tconst tileTypes = new Map();\n\t\t\t\tfor (let orientation of cell.possible) {\n\t\t\t\t\tconst tileType = this.grid.tileTypes.get(orientation) || 0;\n\t\t\t\t\tif (!tileTypes.has(tileType)) {\n\t\t\t\t\t\ttileTypes.set(tileType, new Set());\n\t\t\t\t\t}\n\t\t\t\t\ttileTypes.get(tileType)?.add(orientation);\n\t\t\t\t}\n\t\t\t\tfor (let [tileType, orientations] of tileTypes.entries()) {\n\t\t\t\t\tif (orientations.size === 1) {\n\t\t\t\t\t\tif (!forbidden.has(walls)) {\n\t\t\t\t\t\t\tforbidden.set(walls, new Set());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforbidden.get(walls)?.add(orientations.values().next().value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (visited.length === 0) {\n\t\t\t/** @type {Number} */\n\t\t\tconst startIndex = [...unvisited][Math.floor(Math.random() * unvisited.size)];\n\n\t\t\tvisited.push(startIndex);\n\t\t\tunvisited.delete(startIndex);\n\t\t}\n\n\t\twhile (unvisited.size > 0) {\n\t\t\tlet fromNode = 0;\n\t\t\tconst usePrims = Math.random() < branchingAmount;\n\t\t\tfor (let nodes of [visited, avoiding, lastResortNodes]) {\n\t\t\t\tif (nodes.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (usePrims) {\n\t\t\t\t\t// go from a random element\n\t\t\t\t\tfromNode = getRandomElement(nodes);\n\t\t\t\t} else {\n\t\t\t\t\t// go from the last element\n\t\t\t\t\tfromNode = nodes[nodes.length - 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (fromNode === undefined) {\n\t\t\t\tthrow 'Error in pregeneration: fromNode is undefined';\n\t\t\t}\n\t\t\t// tiers of possible moves\n\t\t\tconst unvisitedNeighbours = []; // these are the best options\n\t\t\tconst straightNeighbours = []; // this move results in a straight tile, might want to avoid\n\t\t\tconst obviousNeighbours = []; // these should be avoided with avoidObvious setting\n\t\t\tconst fullyConnectedNeighbours = []; // making a fully connected tile is a total last resort\n\t\t\tconst connections = tiles[fromNode];\n\t\t\tfor (let direction of this.grid.DIRECTIONS) {\n\t\t\t\tif ((direction & connections) > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst { neighbour, empty } = this.grid.find_neighbour(fromNode, direction);\n\t\t\t\tif (empty || !unvisited.has(neighbour)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// classify this neighbour by priority\n\t\t\t\tif (connections + direction === this.grid.fullyConnected(fromNode)) {\n\t\t\t\t\tfullyConnectedNeighbours.push({ neighbour, direction });\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (borders.has(fromNode) && Math.random() < avoidObvious) {\n\t\t\t\t\tconst walls = borders.get(fromNode) || 0;\n\t\t\t\t\tconst nogo = forbidden.get(walls);\n\t\t\t\t\tif (nogo?.has(tiles[fromNode] + direction)) {\n\t\t\t\t\t\tobviousNeighbours.push({ neighbour, direction });\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.grid.tileTypes.get(connections + direction) === this.grid.T2I) {\n\t\t\t\t\tif (Math.random() < avoidStraights) {\n\t\t\t\t\t\tstraightNeighbours.push({ neighbour, direction });\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tunvisitedNeighbours.push({ neighbour, direction });\n\t\t\t}\n\t\t\tlet toVisit = null;\n\t\t\tlet source = null;\n\t\t\tfor (let options of [\n\t\t\t\tunvisitedNeighbours,\n\t\t\t\tstraightNeighbours,\n\t\t\t\tobviousNeighbours,\n\t\t\t\tfullyConnectedNeighbours\n\t\t\t]) {\n\t\t\t\tif (options.length > 0) {\n\t\t\t\t\tsource = options;\n\t\t\t\t\ttoVisit = getRandomElement(options);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (toVisit === null) {\n\t\t\t\t// all neighbours are already visited\n\t\t\t\tconst array = [visited, avoiding, lastResortNodes].find((x) => x.length > 0) || [];\n\t\t\t\tif (usePrims) {\n\t\t\t\t\tconst index = array.indexOf(fromNode);\n\t\t\t\t\tarray.splice(index, 1);\n\t\t\t\t} else {\n\t\t\t\t\tarray.pop();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (source === fullyConnectedNeighbours) {\n\t\t\t\t// wants to become fully connected, this is a last resort action\n\t\t\t\tif (visited.length > 0) {\n\t\t\t\t\tconst index = visited.indexOf(fromNode);\n\t\t\t\t\tvisited.splice(index, 1);\n\t\t\t\t\tlastResortNodes.push(fromNode);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (source === obviousNeighbours) {\n\t\t\t\t// wants to become obvious, try to avoid using it\n\t\t\t\tif (visited.length > 0) {\n\t\t\t\t\tconst index = visited.indexOf(fromNode);\n\t\t\t\t\tvisited.splice(index, 1);\n\t\t\t\t\tavoiding.push(fromNode);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttiles[fromNode] += toVisit.direction;\n\t\t\ttiles[toVisit.neighbour] += this.grid.OPPOSITE.get(toVisit.direction) || 0;\n\t\t\tunvisited.delete(toVisit.neighbour);\n\t\t\tvisited.push(toVisit.neighbour);\n\t\t}\n\t\treturn tiles;\n\t}\n\n\tgenerate(\n\t\tbranchingAmount = 0.6,\n\t\tavoidObvious = 0.0,\n\t\tavoidStraights = 0.0,\n\t) {\n\t\tlet attempt = 0;\n\t\t// I don't expect many attempts to be needed, just 1 in .9999 cases\n\t\twhile (attempt < 3) {\n\t\t\tattempt += 1;\n\t\t\tlet tiles = this.pregenerate_growingtree(branchingAmount, avoidObvious, avoidStraights);\n\t\t\tlet uniqueIter = 0;\n\t\t\twhile (uniqueIter < 10) {\n\t\t\t\tuniqueIter += 1;\n\t\t\t\tconst solver = new Solver(tiles, this.grid);\n\t\t\t\tconst { marked, unique } = solver.markAmbiguousTiles();\n\t\t\t\tif (unique) {\n\t\t\t\t\treturn randomRotate(marked, this.grid);\n\t\t\t\t}\n\t\t\t\ttiles = this.pregenerate_growingtree(\n\t\t\t\t\tbranchingAmount,\n\t\t\t\t\tavoidObvious,\n\t\t\t\t\tavoidStraights,\n\t\t\t\t\tmarked\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n","import { HexaGrid } from './hexagrid';\nimport { SquareGrid } from './squaregrid';\nimport { OctaGrid } from './octagrid';\n\n/**\n * @typedef {'hexagonal'|'square'|'octagonal'} GridKind\n */\n\n/**\n * @typedef {HexaGrid|SquareGrid|OctaGrid} Grid\n */\n\n/**\n * Creates a grid of a specified type\n * @param {GridKind} kind\n * @param {Number} width\n * @param {Number} height\n * @param {boolean} wrap\n * @param {Number[]|undefined} tiles\n * @returns {Grid}\n */\nexport function createGrid(kind, width, height, wrap, tiles = undefined) {\n\tlet grid;\n\tif (kind === 'hexagonal') {\n\t\tgrid = new HexaGrid(width, height, wrap, tiles);\n\t} else if (kind === 'octagonal') {\n\t\tgrid = new OctaGrid(width, height, wrap, tiles);\n\t} else if (kind === 'square') {\n\t\tgrid = new SquareGrid(width, height, wrap, tiles);\n\t} else {\n\t\tthrow `Unknown grid kind ${kind}`;\n\t}\n\treturn grid;\n}\n\n/** @type {GridKind[]} */\nexport const gridKinds = ['hexagonal', 'square', 'octagonal'];\n\nexport const gridInfo = {\n\thexagonal: {\n\t\ttitle: 'Hexagonal',\n\t\turl: 'hexagonal',\n\t\twrap: true,\n\t\texampleGrid: new HexaGrid(3, 3, false),\n\t\texampleTiles: [32, 34, 32, 50, 56, 8, 12, 20, 16]\n\t},\n\tsquare: {\n\t\ttitle: 'Square',\n\t\turl: 'square',\n\t\twrap: true,\n\t\texampleGrid: new SquareGrid(3, 3, false),\n\t\texampleTiles: [9, 13, 8, 10, 6, 12, 12, 4, 1]\n\t},\n\toctagonal: {\n\t\ttitle: 'Octagonal',\n\t\turl: 'octagonal',\n\t\twrap: true,\n\t\texampleGrid: new OctaGrid(3, 3, false),\n\t\texampleTiles: [32, 64, 192, 18, 68, 66, 5, 200, 128, 130, 168, 0, 40, 8, 0, 0, 0, 0]\n\t}\n};\n","<script>\n\timport { onMount, tick } from 'svelte';\n\timport Puzzle from './lib/puzzle/Puzzle.svelte';\n\timport { createGrid } from './lib/puzzle/grids/grids';\n\timport { Generator } from './lib/puzzle/generator';\n\n\tlet solved = false;\n\tlet grid;\n\tlet tiles = [];\n\tlet id = 0;\n\tlet puzzle;\n\twindow.generate = function(gridTypeName = 'square',size=4){\n\t\tif(['square','hexagonal','octagonal'].includes(gridTypeName)){\n\t\t\tid += 1;\n\t\t\tgrid  = createGrid(gridTypeName, size, size, false);\n\t\t\ttiles = new Generator(grid).generate();\n\t\t}\n\t\telse\n\t\t\tconsole.log('Puzzle URL ')\n\t\t// let gridTypeName = ['square','hexagonal','octagonal'][0];\n\n\t}\n\tonMount(() => {\n\t\t// ? gridTypeName = square & size = 3 \n\t\tif(window.location.search){\n\t\t\tlet queries = window.location.href.split(\"?\")[1].split(\"&\")\n\t\t\twindow.generate(queries[0].split(\"=\")[1], parseInt(queries[1].split(\"=\")[1]))\n\t\t}\n\t\telse\n\t\t\twindow.generate()\n\t\t//  autoSolve() \n\t\t// setTimeout(()=>{\n\t\t// \tautoSolve().then(()=>{\n\t\t// \t\tconsole.log('')\n\t\t// \t})\n\t\t// }, 100)\n\t});\n\n</script>\n\n{#if id > 0}\n\t{#key id}\n\t\t<Puzzle {grid} {tiles}\n\t\t\t\ton:solved={() => (solved = true)}\n\t\t\t\tbind:this={puzzle}\n\t\t\t\tanimate={true}\n\t\t/>\n\t{/key}\n{/if}\n\n","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {\n\t\tname: ''\n\t}\n});\n\nexport default app;"],"names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","component_subscribe","component","store","callback","$$","on_destroy","push","callbacks","unsub","subscribe","unsubscribe","set_store_value","ret","value","set","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","svg_element","name","document","createElementNS","empty","data","createTextNode","attr","attribute","removeAttribute","getAttribute","setAttribute","set_style","key","important","style","removeProperty","setProperty","toggle_class","element","toggle","classList","current_component","set_current_component","onMount","Error","get_current_component","on_mount","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","seen_callbacks","Set","flushidx","flush","saved_component","length","update","e","pop","i","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","d","outro_and_destroy_block","lookup","create_component","mount_component","customElement","m","new_on_destroy","map","filter","destroy_component","detaching","filtered","targets","indexOf","flush_render_callbacks","make_dirty","then","fill","init","options","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","Map","skip_bound","root","ready","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteComponent","$destroy","this","$on","type","index","splice","$set","$$props","obj","$$set","keys","subscriber_queue","writable","start","stop","subscribers","new_value","run_queue","subscriber","invalidate","size","settings","controlMode","invertRotationDirection","showTimer","disableZoomPan","assistant","animationSpeed","createSettings","controls","game","grid","viewBox","unsubscribeViewBox","box","currentSettings","unsubscribeSettings","s","useZoomPan","edgeMarkTimer","state","mouseDownOrigin","x","y","button","tileIndex","tileX","tileY","locking","lockingSet","getEventCoordinates","event","width","height","getBoundingClientRect","relativeX","clientX","relativeY","clientY","xmin","ymin","save","dispatchEvent","CustomEvent","handleMouseDown","preventDefault","tile","which_tile_at","wrap","XMIN","XMAX","YMIN","YMAX","direction","isClose","whichEdge","setTimeout","mark","toggleEdgeMark","handleMouseUp","clearTimeout","dx","dy","distance","Math","sqrt","tileState","tileStates","leftButton","rightButton","rotationTimes","ctrlKey","rotateTile","angle","atan2","timesRotate","clickOrientTile","rotations","addEventListener","destroy","removeEventListener","SINK_RADIUS","circle","circle_fill_value","color","create_if_block","path0","path0_d_value","getTilePath","path2","path2_stroke_value","getAngle","g1","g1_transform_value","g0","path1","if_block","cx","cy","disconnectStrokeWidthScale","disconnectStrokeColor","strokeColor","strokeWidth","STROKE_WIDTH","outlineWidth","PIPE_WIDTH","myDirections","getDirections","$state","getGuideDotPosition","pipeWidth","path","getPipesPath","isSink","hasDisconnects","$$invalidate","$disconnectStrokeWidthScale","isPartOfIsland","factory","randomColor","seed","colorDictionary","loadColorBounds","colorRanges","undefined","parseInt","stringToInteger","TypeError","H","S","count","totalColors","colors","setFormat","pickHue","pickSaturation","pickBrightness","hue","randomWithin","hueRange","getRealHueRange","step","j","getHueRange","luminosity","saturationRange","getSaturationRange","sMin","sMax","bMin","getMinimumBrightness","bMax","hsv","format","HSVtoHSL","hsl","hslColor","alpha","random","HSVtoRGB","join","rgbColor","HSVtoHex","lowerBounds","getColorInfo","s1","v1","s2","v2","colorInput","number","match","HexToHSB","colorName","range","golden_ratio","floor","max","min","rnd","rgb","componentToHex","hex","toString","defineColor","brightnessRange","h","v","h_i","f","q","t","g","replace","red","substr","green","blue","cMax","delta","saturation","k","round","string","total","Number","MAX_SAFE_INTEGER","charCodeAt","colorHue","isNaN","module","exports","createViewBox","initial","lastBox","visibleTilesTimeoutId","visibleTiles","visible","getVisibleTiles","pan","dw","dh","fixBoxBounds","StateStore","initialState","self","assign","newValue","setColor","toggleLocked","locked","setPartOfLoop","isPartOfLoop","setPartOfIsland","setHasDisconnects","rotate","times","PipesGame","tiles","savedProgress","initialized","_solved","solved","connections","components","openEnds","totalTiles","emptyCells","shareDisconnectedTiles","amount","defaultEdgeMarks","edgeMarks","EDGEMARK_DIRECTIONS","direction_index","find_neighbour","initializeBoard","directions","neighbour","checked","toCheck","connectedThrough","loop","values","next","connected","get","through","loopTiles","detectLoops","loopTile","islandTile","oldDirections","newDirections","dirOut","some","dirIn","handleConnections","detail","setTileOrientation","orientation","animate","newState","DIRECTIONS","opposite","OPPOSITE","rotateToMatchMarks","walls","oppositeIndex","rotated","tileConnections","neighbourConnections","neighbourComponent","disconnectComponents","setTileDisconnects","mergeComponents","isSolved","newHasDisconnects","firstValidIndex","startCheckAtIndex","fromIndex","newChecks","neighbours","toIndex","fromComponent","toComponent","fromIsBigger","constantComponent","changedComponent","newColor","changedTile","bigComponent","fromTiles","findConnectedTiles","toTiles","changeTiles","newComponent","tilesSet","myConnections","toPrune","inComponent","conn","pruneTile","neighbourConn","pruneDeadEnds","n","inLoops","traceLoopPath","fromTile","throughTile","paths","lastTile","slice","tileToCheck","nConn","myComponent","RegularPolygonTile","constructor","num_directions","angle_offset","radius_in","border_width","angle_unit","PI","radius_out","cos","side_length","sin","direction_to_index","fully_connected","reduce","contour_path","cache","pipes_path","guide_dot_position","edgemark_line","normalize_rotations","half","cached","result","entries","rotated_index","get_angle","get_directions","get_pipes_path","get_guide_dot_position","legs","leg","abs","distances","next_leg","every","distance_sums","multiple","sum_index","min_sum","base_leg_index","click_orient_tile","old_rotations","new_angle","guideX","guideY","old_angle","times_rotate","detect_edgemark_gesture","x1","x2","y1","y2","start_angle","end_angle","delta_angle","mean_angle","start_radius","end_radius","mean_radius","radius_is_close","angle_is_close","distance_along_border","distance_across_border","is_close_to_edge","delta_radius","direction_angle","get_edgemark_line","ax","ay","offset_x","offset_y","line","SOUTHWEST","SOUTHEAST","YSTEP","HEXAGON","HexaGrid","NUM_DIRECTIONS","KIND","PIPE_LENGTH","RC_DELTA","T0","T1","T2v","T2c","T2I","T3w","T3y","T3la","T3Y","T4K","T4X","T4psi","T5","T6","tileTypes","index_to_xy","r0","c0","x0","y0","distance0","rc_to_index","r1","ceil","c1","dr","dc","evenRow","makeEmpty","fullyConnected","rmin","rmax","cmin","cmax","useShape","shape","middle_row","left_cell","right_cell","start_cell","shift_direction","erase_direction","cell","delta_row","new_cell","console","log","getEdgemarkLine","detectEdgemarkGesture","tile_index","tile_x","tile_y","point","NoOrientationsPossibleException","message","LoopDetectedException","IslandDetectedException","Cell","possible","addWall","addConnection","mustHaveAllWalls","mustHaveSomeWalls","mustHaveAllConnections","applyConstraints","newPossible","full","newWalls","newConnections","addedWalls","addedConnections","clone","Solver","UNSOLVED","AMBIGUOUS","unsolved","solution","solutions","checkDeadendConnections","getCell","doLocalDeductions","neighbourIndex","otherIndex","occupiedDirections","forbidden","nIndex","possibleBefore","neighbourTiles","invalidDirections","deadendConnections","neighbourTile","processDirtyCells","final","componentCell","makeAGuess","minPossibleSize","POSITIVE_INFINITY","guessIndex","solve","allSolutions","toInit","nextTile","stage","trials","guess","solver","lastTrial","error","parent","markAmbiguousTiles","marked","unique","solvable","_","tile_changes","get_key","createElement","svg","svg_viewBox_value","div","handler","action_result","call","old_blocks","dynamic","list","create_each_block","get_context","old_indexes","new_blocks","new_lookup","deltas","updates","child_ctx","will_move","did_move","first","new_block","old_block","new_key","old_key","current","$viewBox","innerWidth","innerHeight","window","autoSolve","async","sleep","ms","$solved","shouldLock","isSame","onPuzzleSolved","SQUARE","SquareGrid","XY_DELTAS","T2L","T3","EAST","NORTH","WEST","SOUTH","Rsq","SQRT2","OCTAGON","OctaGrid","RC_DELTAS","SQRT1_2","ANGLE_DEG","ANGLE_RAD","N","w","T2C","isSquare","xm","ym","squareIndexOffset","indexOct","rs","cs","indexSquare","tile_at","getRandomElement","array","randomRotate","numDirections","Generator","pregenerate_growingtree","branchingAmount","avoidObvious","avoidStraights","startTiles","unvisited","visited","avoiding","lastResortNodes","to_check","to_visit","sort","borders","tileType","orientations","startIndex","fromNode","usePrims","unvisitedNeighbours","straightNeighbours","obviousNeighbours","fullyConnectedNeighbours","nogo","toVisit","source","find","generate","attempt","uniqueIter","puzzle","id","gridTypeName","includes","kind","createGrid","location","search","queries","href","split","$$value","body"],"mappings":"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","x_google_ignoreList":[0,1,5]}